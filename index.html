<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced Speech Processing Suite - Convert Speech to Text and Text to Speech with Neural Voices">
    <meta name="keywords" content="speech to text, text to speech, TTS, STT, voice recognition, neural voices">
    <meta name="author" content="Jay">
    <title>STT & TTS - Speech Processing</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/icons8-favorite-48.png">
    <link rel="shortcut icon" type="image/png" href="assets/icons8-favorite-48.png">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="css/inter-font.css">
    <link rel="stylesheet" href="css/fontawesome.css">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/fallbacks.css">
</head>
<body>
    <div class="header">
        <h1>üéôÔ∏è STT & TTS</h1>
        <p>Advanced Speech Processing - Convert Speech to Text and Text to Speech</p>
    </div>

    <div class="container">
        <!-- Speech to Text Section -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-microphone"></i>
                <h2>Speech to Text</h2>
            </div>

            <div class="status-indicator" id="stt_status">
                <i class="fas fa-circle"></i>
                <span>Ready to Listen</span>
            </div>

            <div class="form-group">
                <label for="language_select">Recognition Language</label>
                <select id="language_select" class="form-control">
                    <option value="en-US">English (US)</option>
                    <option value="en-GB">English (UK)</option>
                    <option value="en-AU">English (Australia)</option>
                    <option value="en-CA">English (Canada)</option>
                    <option value="en-IN">English (India)</option>
                    <option value="es-ES">Spanish (Spain)</option>
                    <option value="es-MX">Spanish (Mexico)</option>
                    <option value="fr-FR">French (France)</option>
                    <option value="fr-CA">French (Canada)</option>
                    <option value="de-DE">German (Germany)</option>
                    <option value="it-IT">Italian (Italy)</option>
                    <option value="pt-BR">Portuguese (Brazil)</option>
                    <option value="pt-PT">Portuguese (Portugal)</option>
                    <option value="ru-RU">Russian (Russia)</option>
                    <option value="ja-JP">Japanese (Japan)</option>
                    <option value="ko-KR">Korean (Korea)</option>
                    <option value="zh-CN">Chinese (Mandarin)</option>
                    <option value="zh-TW">Chinese (Traditional)</option>
                    <option value="ar-SA">Arabic (Saudi Arabia)</option>
                    <option value="hi-IN">Hindi (India)</option>
                    <option value="th-TH">Thai (Thailand)</option>
                    <option value="vi-VN">Vietnamese (Vietnam)</option>
                    <option value="nl-NL">Dutch (Netherlands)</option>
                    <option value="sv-SE">Swedish (Sweden)</option>
                    <option value="da-DK">Danish (Denmark)</option>
                    <option value="no-NO">Norwegian (Norway)</option>
                    <option value="fi-FI">Finnish (Finland)</option>
                    <option value="pl-PL">Polish (Poland)</option>
                    <option value="cs-CZ">Czech (Czech Republic)</option>
                    <option value="hu-HU">Hungarian (Hungary)</option>
                    <option value="ro-RO">Romanian (Romania)</option>
                    <option value="bg-BG">Bulgarian (Bulgaria)</option>
                    <option value="hr-HR">Croatian (Croatia)</option>
                    <option value="sk-SK">Slovak (Slovakia)</option>
                    <option value="sl-SI">Slovenian (Slovenia)</option>
                    <option value="et-EE">Estonian (Estonia)</option>
                    <option value="lv-LV">Latvian (Latvia)</option>
                    <option value="lt-LT">Lithuanian (Lithuania)</option>
                    <option value="mt-MT">Maltese (Malta)</option>
                </select>
            </div>

            <div class="btn-group">
                <button id="click_to_record" class="btn btn-primary">
                    <i class="fas fa-microphone"></i>
                    Start Recording
                </button>
                <button id="stop_recording" class="btn btn-danger" disabled>
                    <i class="fas fa-stop"></i>
                    Stop Recording
                </button>
                <button id="clear_transcript" class="btn btn-warning">
                    <i class="fas fa-trash"></i>
                    Clear
                </button>
            </div>

            <div class="form-group">
                <label>Transcription Output</label>
                <div class="output-area">
                    <div id="convert_text" class="transcript-text">Your speech will appear here...</div>
                </div>
            </div>

            <div id="wave_animation" class="wave-animation" style="display: none;">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>

            <!-- Hidden status element for Python integration -->
            <div id="is_recording" style="display: none;">Recording: False</div>
        </div>

        <!-- Text to Speech Section -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-volume-up"></i>
                <h2>Text to Speech</h2>
            </div>

            <div class="status-indicator" id="tts_status">
                <i class="fas fa-circle"></i>
                <span>Ready to Speak</span>
            </div>

            <div class="form-group">
                <label for="tts_voice_select">Voice Selection</label>
                <select id="tts_voice_select" class="form-control">
                    <option value="en-US-JennyNeural">Jenny (US) - Friendly Female</option>
                    <option value="en-US-GuyNeural">Guy (US) - Friendly Male</option>
                    <option value="en-US-AriaNeural">Aria (US) - News Female</option>
                    <option value="en-US-DavisNeural">Davis (US) - News Male</option>
                    <option value="en-US-AmberNeural">Amber (US) - Warm Female</option>
                    <option value="en-US-AnaNeural">Ana (US) - Child Female</option>
                    <option value="en-US-BrandonNeural">Brandon (US) - Young Male</option>
                    <option value="en-US-ChristopherNeural">Christopher (US) - Professional Male</option>
                    <option value="en-US-CoraNeural">Cora (US) - Mature Female</option>
                    <option value="en-US-ElizabethNeural">Elizabeth (US) - Calm Female</option>
                    <option value="en-US-EricNeural">Eric (US) - Casual Male</option>
                    <option value="en-US-JacobNeural">Jacob (US) - Conversational Male</option>
                    <option value="en-US-JaneNeural">Jane (US) - Clear Female</option>
                    <option value="en-US-JasonNeural">Jason (US) - Energetic Male</option>
                    <option value="en-US-MichelleNeural">Michelle (US) - Expressive Female</option>
                    <option value="en-US-MonicaNeural">Monica (US) - Pleasant Female</option>
                    <option value="en-US-NancyNeural">Nancy (US) - Storyteller Female</option>
                    <option value="en-US-RogerNeural">Roger (US) - Deep Male</option>
                    <option value="en-US-SaraNeural">Sara (US) - Gentle Female</option>
                    <option value="en-US-SteffanNeural">Steffan (US) - Warm Male</option>
                    <option value="en-GB-SoniaNeural">Sonia (UK) - British Female</option>
                    <option value="en-GB-RyanNeural">Ryan (UK) - British Male</option>
                    <option value="en-AU-NatashaNeural">Natasha (AU) - Australian Female</option>
                    <option value="en-AU-WilliamNeural">William (AU) - Australian Male</option>
                    <option value="en-CA-ClaraNeural">Clara (CA) - Canadian Female</option>
                    <option value="en-CA-LiamNeural">Liam (CA) - Canadian Male</option>
                    <option value="en-IN-NeerjaNeural">Neerja (IN) - Indian Female</option>
                    <option value="en-IN-PrabhatNeural">Prabhat (IN) - Indian Male</option>
                </select>
            </div>

            <div class="range-group">
                <div class="range-control">
                    <label for="speech_rate">Speech Rate</label>
                    <input type="range" id="speech_rate" min="0.5" max="2.0" value="1.0" step="0.1">
                    <div class="range-value" id="rate_value">1.0x</div>
                </div>
                <div class="range-control">
                    <label for="speech_volume">Volume</label>
                    <input type="range" id="speech_volume" min="0.0" max="1.0" value="0.8" step="0.1">
                    <div class="range-value" id="volume_value">80%</div>
                </div>
            </div>

            <div class="form-group">
                <label for="text_input">Text to Convert</label>
                <textarea id="text_input" class="form-control" rows="4" placeholder="Enter text to convert to speech..."></textarea>
            </div>

            <div class="btn-group">
                <button id="speak_text" class="btn btn-success">
                    <i class="fas fa-play"></i>
                    Speak Text
                </button>
                <button id="stop_speech" class="btn btn-danger" disabled>
                    <i class="fas fa-stop"></i>
                    Stop Speech
                </button>
                <button id="save_audio" class="btn btn-primary">
                    <i class="fas fa-download"></i>
                    Save Audio
                </button>
                <button id="use_transcript" class="btn btn-warning">
                    <i class="fas fa-arrow-left"></i>
                    Use Transcript
                </button>
                <button id="test_voice" class="btn btn-secondary" style="display: none;">
                    <i class="fas fa-vial"></i>
                    Test Voice
                </button>
                <button id="cycle_voices" class="btn btn-info" style="display: none;">
                    <i class="fas fa-random"></i>
                    Cycle Voices
                </button>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Made with ‚ù§Ô∏è by <a href="https://github.com/Jaikishan1228" target="_blank">Jay</a> | 
        <a href="https://github.com/Jaikishan1228/TTS-STT" target="_blank">GitHub Repository</a></p>
    </div>

    <script>
        // Global variables
        let recognition = null;
        let isRecording = false;
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;

        // DOM Elements
        const sttStatus = document.getElementById('stt_status');
        const ttsStatus = document.getElementById('tts_status');
        const recordBtn = document.getElementById('click_to_record');
        const stopBtn = document.getElementById('stop_recording');
        const clearBtn = document.getElementById('clear_transcript');
        const transcriptArea = document.getElementById('convert_text');
        const isRecordingDiv = document.getElementById('is_recording');
        const waveAnimation = document.getElementById('wave_animation');
        const languageSelect = document.getElementById('language_select');
        
        const voiceSelect = document.getElementById('tts_voice_select');
        const speechRateSlider = document.getElementById('speech_rate');
        const speechVolumeSlider = document.getElementById('speech_volume');
        const rateValue = document.getElementById('rate_value');
        const volumeValue = document.getElementById('volume_value');
        const textInput = document.getElementById('text_input');
        const speakBtn = document.getElementById('speak_text');
        const stopSpeechBtn = document.getElementById('stop_speech');
        const saveAudioBtn = document.getElementById('save_audio');
        const useTranscriptBtn = document.getElementById('use_transcript');
        const testVoiceBtn = document.getElementById('test_voice');
        const cycleVoicesBtn = document.getElementById('cycle_voices');

        // Enhanced browser compatibility check with mobile detection
        function checkBrowserSupport() {
            const userAgent = navigator.userAgent;
            const isChrome = /Chrome/.test(userAgent) && /Google Inc/.test(navigator.vendor);
            const isEdge = /Edg/.test(userAgent);
            const isFirefox = /Firefox/.test(userAgent);
            const isSafari = /Safari/.test(userAgent) && !/Chrome/.test(userAgent);
            
            // Mobile device detection
            const isAndroid = /Android/.test(userAgent);
            const isIOS = /iPad|iPhone|iPod/.test(userAgent);
            const isMobile = /Mobile|Android|iPhone|iPad/.test(userAgent);
            
            // Android-specific browser detection
            const isAndroidChrome = isAndroid && isChrome;
            const isAndroidFirefox = isAndroid && isFirefox;
            const isAndroidSamsung = isAndroid && /SamsungBrowser/.test(userAgent);
            const isAndroidWebView = isAndroid && /wv/.test(userAgent);
            
            console.log('üåê Browser & Device detected:', {
                chrome: isChrome,
                edge: isEdge,
                firefox: isFirefox,
                safari: isSafari,
                android: isAndroid,
                iOS: isIOS,
                mobile: isMobile,
                androidChrome: isAndroidChrome,
                androidFirefox: isAndroidFirefox,
                androidSamsung: isAndroidSamsung,
                androidWebView: isAndroidWebView,
                userAgent: userAgent
            });
            
            return { 
                isChrome, isEdge, isFirefox, isSafari, 
                isAndroid, isIOS, isMobile,
                isAndroidChrome, isAndroidFirefox, isAndroidSamsung, isAndroidWebView
            };
        }

        const browserInfo = checkBrowserSupport();

        // Initialize Speech Recognition with enhanced browser support
        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                try {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognition = new SpeechRecognition();
                    
                    // Enhanced configuration for better browser compatibility
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.lang = languageSelect.value;
                    recognition.maxAlternatives = 1;
                    
                    // Browser-specific optimizations
                    if (browserInfo.isAndroid) {
                        // Android browsers need special handling
                        recognition.continuous = false; // Android works better with single recognition
                        recognition.interimResults = true;
                        recognition.maxAlternatives = 1;
                        console.log('ü§ñ Android optimization: Single recognition mode');
                    } else if (browserInfo.isChrome || browserInfo.isEdge) {
                        recognition.continuous = true;
                        recognition.interimResults = true;
                    } else if (browserInfo.isFirefox) {
                        // Firefox has limited support, use more conservative settings
                        recognition.continuous = false;
                        recognition.interimResults = false;
                    } else if (browserInfo.isSafari) {
                        // Safari needs special handling
                        recognition.continuous = false;
                        recognition.interimResults = true;
                    }
                    
                    console.log('üé§ Speech Recognition initialized with language:', languageSelect.value);
                    return true;
                } catch (error) {
                    console.error('üî¥ Speech Recognition initialization failed:', error);
                    return false;
                }
            }
            return false;
        }

        // Initialize speech recognition
        const speechRecognitionSupported = initializeSpeechRecognition();

        if (speechRecognitionSupported && recognition) {
            recognition.onstart = function() {
                updateSTTStatus('recording', 'Recording... Speak now!');
                isRecording = true;
                isRecordingDiv.textContent = 'Recording: True';
                recordBtn.disabled = true;
                stopBtn.disabled = false;
                waveAnimation.style.display = 'flex';
            };

            recognition.onresult = function(event) {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Clear placeholder text first
                if (transcriptArea.textContent === 'Your speech will appear here...') {
                    transcriptArea.textContent = '';
                }

                // Update transcript display with both final and interim results
                const existingFinalText = transcriptArea.dataset.finalText || '';
                transcriptArea.dataset.finalText = existingFinalText + finalTranscript;
                transcriptArea.textContent = transcriptArea.dataset.finalText + interimTranscript;
                
                // Auto-scroll to bottom
                transcriptArea.scrollTop = transcriptArea.scrollHeight;
            };

            recognition.onerror = function(event) {
                console.error('üî¥ Speech Recognition Error:', event.error, event);
                
                let errorMessage = 'Error: ';
                let userAction = '';
                
                switch(event.error) {
                    case 'not-allowed':
                        errorMessage += 'Microphone permission denied';
                        userAction = 'Please click the microphone icon in your browser\'s address bar and allow access';
                        break;
                    case 'no-speech':
                        errorMessage += 'No speech detected';
                        userAction = 'Please speak closer to your microphone and try again';
                        break;
                    case 'audio-capture':
                        errorMessage += 'Microphone error';
                        userAction = 'Check your microphone connection and browser permissions';
                        break;
                    case 'network':
                        errorMessage += 'Network error';
                        userAction = 'Check your internet connection';
                        break;
                    case 'service-not-allowed':
                        errorMessage += 'Speech service not allowed';
                        if (browserInfo.isFirefox) {
                            userAction = 'Enable speech recognition in Firefox: about:config ‚Üí media.webspeech.recognition.enable ‚Üí true';
                        } else {
                            userAction = 'Try using Chrome or Edge for better compatibility';
                        }
                        break;
                    case 'bad-grammar':
                        errorMessage += 'Grammar error';
                        userAction = 'Try speaking more clearly';
                        break;
                    case 'language-not-supported':
                        errorMessage += 'Language not supported';
                        userAction = 'Try switching to English or another supported language';
                        break;
                    default:
                        errorMessage += event.error;
                        userAction = 'Try refreshing the page or using a different browser';
                }
                
                updateSTTStatus('idle', errorMessage);
                
                // Show detailed user guidance
                if (userAction) {
                    setTimeout(() => {
                        const helpDiv = document.createElement('div');
                        helpDiv.style.cssText = `
                            position: fixed;
                            bottom: 20px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: #ff6b6b;
                            color: white;
                            padding: 15px 20px;
                            border-radius: 8px;
                            max-width: 400px;
                            text-align: center;
                            font-size: 14px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                        `;
                        helpDiv.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 8px;">üí° How to fix this:</div>
                            <div>${userAction}</div>
                            <button onclick="this.parentElement.remove()" style="margin-top: 10px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 5px 15px; border-radius: 4px; cursor: pointer;">Got it</button>
                        `;
                        document.body.appendChild(helpDiv);
                        
                        setTimeout(() => {
                            if (document.body.contains(helpDiv)) {
                                helpDiv.remove();
                            }
                        }, 10000);
                    }, 1000);
                }
                
                resetRecording();
            };

            recognition.onend = function() {
                updateSTTStatus('success', 'Transcription completed');
                resetRecording();
                
                // Show final result
                const finalText = transcriptArea.dataset.finalText || transcriptArea.textContent;
                if (finalText && finalText !== 'Your speech will appear here...') {
                    transcriptArea.textContent = finalText.trim();
                    console.log('üìù Final transcript:', finalText.trim());
                }
                
                setTimeout(() => updateSTTStatus('idle', 'Ready to Listen'), 2000);
            };
        } else {
            let errorMessage = 'Speech Recognition not supported in this browser';
            if (browserInfo.isFirefox) {
                errorMessage = 'Firefox: Enable speech recognition in about:config (media.webspeech.recognition.enable)';
            } else if (browserInfo.isSafari) {
                errorMessage = 'Safari: Speech Recognition has limited support';
            }
            updateSTTStatus('idle', errorMessage);
            recordBtn.disabled = true;
        }

        // Request microphone permission early
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    console.log('üé§ Microphone permission granted');
                    stream.getTracks().forEach(track => track.stop()); // Stop the stream
                    updateSTTStatus('success', 'Microphone ready');
                    setTimeout(() => updateSTTStatus('idle', 'Ready to Listen'), 2000);
                })
                .catch(function(err) {
                    console.warn('üî¥ Microphone permission denied:', err);
                    updateSTTStatus('idle', 'Microphone permission needed');
                });
        }

        // Enhanced STT Event Listeners with browser compatibility
        recordBtn.addEventListener('click', async function(event) {
            event.preventDefault();
            
            if (!recognition) {
                updateSTTStatus('idle', 'Speech Recognition not available');
                return;
            }
            
            if (isRecording) {
                updateSTTStatus('idle', 'Already recording');
                return;
            }

            try {
                // Request microphone permission explicitly
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop()); // Stop the stream immediately
                        console.log('üé§ Microphone permission confirmed');
                    } catch (permissionError) {
                        updateSTTStatus('idle', 'Microphone permission denied');
                        alert('Please allow microphone access to use speech recognition');
                        return;
                    }
                }

                // Add delay for browser compatibility
                setTimeout(() => {
                    try {
                        recognition.start();
                        console.log('üé§ Speech recognition started');
                    } catch (startError) {
                        console.error('üî¥ Failed to start recognition:', startError);
                        updateSTTStatus('idle', 'Failed to start recording: ' + startError.message);
                        resetRecording();
                    }
                }, 100);
                
            } catch (error) {
                console.error('üî¥ Recording error:', error);
                updateSTTStatus('idle', 'Recording error: ' + error.message);
                resetRecording();
            }
        });

        stopBtn.addEventListener('click', function(event) {
            event.preventDefault();
            
            if (recognition && isRecording) {
                try {
                    recognition.stop();
                    console.log('üé§ Speech recognition stopped');
                } catch (stopError) {
                    console.error('üî¥ Failed to stop recognition:', stopError);
                    resetRecording();
                }
            }
        });

        clearBtn.addEventListener('click', clearTranscript);

        languageSelect.addEventListener('change', function() {
            if (recognition) {
                recognition.lang = this.value;
            }
        });

        // TTS Event Listeners
        speechRateSlider.addEventListener('input', function() {
            rateValue.textContent = this.value + 'x';
        });

        speechVolumeSlider.addEventListener('input', function() {
            volumeValue.textContent = Math.round(this.value * 100) + '%';
        });

        speakBtn.addEventListener('click', function() {
            const text = textInput.value.trim();
            if (!text) {
                alert('Please enter text to speak');
                return;
            }

            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }

            console.log('üîä Starting TTS with:', {
                text: text.substring(0, 50) + '...',
                selectedVoice: voiceSelect.value,
                rate: speechRateSlider.value,
                volume: speechVolumeSlider.value
            });

            updateTTSStatus('processing', 'Generating speech...');
            
            // For actual TTS, we'll use Web Speech API as a demo
            // In production, this would call your TTS.py backend
            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.rate = parseFloat(speechRateSlider.value);
            currentUtterance.volume = parseFloat(speechVolumeSlider.value);
            
            // Properly match voice selection with available system voices
            const voices = speechSynthesis.getVoices();
            const selectedVoice = voiceSelect.value;
            
            // Extract language and gender preferences from selected voice
            let targetLang = 'en-US';
            let preferredGender = 'female';
            let voiceName = '';
            
            // Parse the selected Neural voice
            if (selectedVoice.includes('en-US')) targetLang = 'en-US';
            else if (selectedVoice.includes('en-GB')) targetLang = 'en-GB';
            else if (selectedVoice.includes('en-AU')) targetLang = 'en-AU';
            else if (selectedVoice.includes('en-CA')) targetLang = 'en-CA';
            else if (selectedVoice.includes('en-IN')) targetLang = 'en-IN';
            
            // Extract the voice name (e.g., "Jenny" from "en-US-JennyNeural")
            const voiceMatch = selectedVoice.match(/en-[A-Z]{2}-([A-Za-z]+)Neural/);
            if (voiceMatch) {
                voiceName = voiceMatch[1].toLowerCase();
            }
            
            // Comprehensive male voice detection
            const maleVoices = [
                'guy', 'davis', 'brandon', 'christopher', 'eric', 'jacob', 
                'jason', 'roger', 'steffan', 'ryan', 'william', 'liam', 
                'prabhat', 'mark', 'george', 'david', 'james', 'thomas',
                'male', 'man', 'boy'
            ];
            
            const femaleVoices = [
                'jenny', 'aria', 'amber', 'ana', 'cora', 'elizabeth', 
                'jane', 'michelle', 'monica', 'nancy', 'sara', 'sonia',
                'natasha', 'clara', 'neerja', 'susan', 'hazel', 'zira',
                'female', 'woman', 'girl'
            ];
            
            // Determine gender preference
            if (maleVoices.includes(voiceName)) {
                preferredGender = 'male';
            } else if (femaleVoices.includes(voiceName)) {
                preferredGender = 'female';
            } else {
                // Default based on common patterns
                preferredGender = maleVoices.some(name => selectedVoice.toLowerCase().includes(name)) ? 'male' : 'female';
            }
            
            // Enhanced voice matching with Android-specific handling
            function findBestVoice(voices, selectedVoice, targetLang, preferredGender, voiceName) {
                let bestVoice = null;
                let bestScore = -1;
                const fallbackVoices = [];
                
                console.log(`üîç Looking for voice: ${selectedVoice} (${targetLang}, ${preferredGender}, ${voiceName})`);
                console.log(`üé§ Available voices (${voices.length}):`, voices.map(v => `${v.name} (${v.lang})`));
                
                // Detailed Android voice analysis
                if (browserInfo.isAndroid && voices.length > 10) {
                    console.log('ü§ñ Android Voice Analysis:');
                    const voiceAnalysis = voices.map(voice => ({
                        name: voice.name,
                        lang: voice.lang,
                        default: voice.default,
                        localService: voice.localService,
                        voiceURI: voice.voiceURI
                    }));
                    console.table(voiceAnalysis);
                }
                
                // Android-specific voice handling - Direct approach for 87 voices
                if (browserInfo.isAndroid) {
                    console.log('ü§ñ Android detected - Direct voice selection from 87 voices');
                    console.log(`ü§ñ Requested: ${selectedVoice} ‚Üí Target: ${targetLang}, Gender: ${preferredGender}, Name: ${voiceName}`);
                    
                    // Strategy 1: Try exact name matching first
                    if (voiceName) {
                        const exactNameMatch = voices.find(voice => 
                            voice.name.toLowerCase().includes(voiceName.toLowerCase())
                        );
                        if (exactNameMatch) {
                            console.log(`ü§ñ ‚úÖ Exact name match: ${exactNameMatch.name} (${exactNameMatch.lang})`);
                            return exactNameMatch;
                        }
                    }
                    
                    // Strategy 2: Language + Gender combination
                    const langGenderMatches = voices.filter(voice => {
                        const matchesLang = voice.lang === targetLang || voice.lang.startsWith(targetLang.split('-')[0]);
                        const name = voice.name.toLowerCase();
                        const matchesGender = preferredGender === 'male' ? 
                            (maleVoices.some(male => name.includes(male)) || name.includes('male') || name.includes('man')) :
                            (femaleVoices.some(female => name.includes(female)) || name.includes('female') || name.includes('woman'));
                        return matchesLang && matchesGender;
                    });
                    
                    if (langGenderMatches.length > 0) {
                        // Pick the first good match or prefer Google/Android voices
                        const preferredMatch = langGenderMatches.find(voice => 
                            voice.name.toLowerCase().includes('google') || 
                            voice.name.toLowerCase().includes('android')
                        ) || langGenderMatches[0];
                        
                        console.log(`ü§ñ ‚úÖ Lang+Gender match: ${preferredMatch.name} (${preferredMatch.lang})`);
                        console.log(`ü§ñ Other options (${langGenderMatches.length}):`, langGenderMatches.map(v => v.name));
                        return preferredMatch;
                    }
                    
                    // Strategy 3: Just language matching
                    const langMatches = voices.filter(voice => 
                        voice.lang === targetLang || voice.lang.startsWith(targetLang.split('-')[0])
                    );
                    
                    if (langMatches.length > 0) {
                        console.log(`ü§ñ ‚úÖ Language match: ${langMatches[0].name} (${langMatches[0].lang})`);
                        console.log(`ü§ñ Lang options (${langMatches.length}):`, langMatches.map(v => v.name));
                        return langMatches[0];
                    }
                    
                    // Strategy 4: Gender matching only
                    const genderMatches = voices.filter(voice => {
                        const name = voice.name.toLowerCase();
                        return preferredGender === 'male' ? 
                            (maleVoices.some(male => name.includes(male)) || name.includes('male') || name.includes('man')) :
                            (femaleVoices.some(female => name.includes(female)) || name.includes('female') || name.includes('woman'));
                    });
                    
                    if (genderMatches.length > 0) {
                        console.log(`ü§ñ ‚úÖ Gender match: ${genderMatches[0].name} (${genderMatches[0].lang})`);
                        console.log(`ü§ñ Gender options (${genderMatches.length}):`, genderMatches.map(v => v.name));
                        return genderMatches[0];
                    }
                    
                    // Strategy 5: Use a different voice each time (round-robin for testing)
                    const voiceIndex = Math.floor(Math.random() * Math.min(voices.length, 10)); // Random from first 10
                    const randomVoice = voices[voiceIndex];
                    console.log(`ü§ñ ‚úÖ Random voice (${voiceIndex}): ${randomVoice.name} (${randomVoice.lang})`);
                    return randomVoice;
                }
                
                voices.forEach(voice => {
                    let score = 0;
                    const sysVoiceName = voice.name.toLowerCase();
                    const sysVoiceLang = voice.lang;
                    
                    // Store potential fallbacks
                    if (sysVoiceLang.startsWith('en')) {
                        fallbackVoices.push(voice);
                    }
                    
                    // Language matching (highest priority)
                    if (sysVoiceLang === targetLang) {
                        score += 100;
                    } else if (sysVoiceLang.startsWith(targetLang.split('-')[0])) {
                        score += 50; // Same language, different region
                    } else if (sysVoiceLang.startsWith('en')) {
                        score += 25; // Any English
                    }
                    
                    // Exact name matching (very high priority)
                    if (voiceName && sysVoiceName.includes(voiceName)) {
                        score += 200;
                    }
                    
                    // Partial name matching
                    if (voiceName) {
                        const voiceWords = voiceName.split(' ');
                        voiceWords.forEach(word => {
                            if (word.length > 2 && sysVoiceName.includes(word.toLowerCase())) {
                                score += 50;
                            }
                        });
                    }
                    
                    // Gender matching
                    const isMaleVoice = maleVoices.some(male => sysVoiceName.includes(male)) ||
                                       sysVoiceName.includes('male') || sysVoiceName.includes('man');
                    const isFemaleVoice = femaleVoices.some(female => sysVoiceName.includes(female)) ||
                                         sysVoiceName.includes('female') || sysVoiceName.includes('woman');
                    
                    if (preferredGender === 'male' && isMaleVoice) {
                        score += 75;
                    } else if (preferredGender === 'female' && isFemaleVoice) {
                        score += 75;
                    } else if (preferredGender === 'male' && isFemaleVoice) {
                        score -= 25; // Reduced penalty
                    } else if (preferredGender === 'female' && isMaleVoice) {
                        score -= 25; // Reduced penalty
                    }
                    
                    // Quality bonus for Neural/Natural voices
                    if (sysVoiceName.includes('neural') || sysVoiceName.includes('natural') || 
                        sysVoiceName.includes('premium') || sysVoiceName.includes('enhanced')) {
                        score += 15;
                    }
                    
                    // Browser-specific voice preferences
                    if (browserInfo.isChrome && sysVoiceName.includes('google')) {
                        score += 10;
                    } else if (browserInfo.isEdge && sysVoiceName.includes('microsoft')) {
                        score += 10;
                    } else if (browserInfo.isSafari && sysVoiceName.includes('alex')) {
                        score += 10;
                    }
                    
                    console.log(`  ${voice.name} (${voice.lang}): score ${score}`);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestVoice = voice;
                    }
                });
                
                // Enhanced fallback logic
                if (!bestVoice || bestScore < 25) {
                    console.log('üîÑ Using fallback voice selection...');
                    
                    // Try different fallback strategies
                    const strategies = [
                        () => fallbackVoices.find(v => v.lang === targetLang),
                        () => fallbackVoices.find(v => v.lang.startsWith(targetLang.split('-')[0])),
                        () => fallbackVoices.find(v => preferredGender === 'female' ? 
                            femaleVoices.some(f => v.name.toLowerCase().includes(f)) :
                            maleVoices.some(m => v.name.toLowerCase().includes(m))),
                        () => fallbackVoices[0],
                        () => voices[0]
                    ];
                    
                    for (const strategy of strategies) {
                        const voice = strategy();
                        if (voice) {
                            bestVoice = voice;
                            console.log(`üì¢ Fallback voice selected: ${voice.name} (${voice.lang})`);
                            break;
                        }
                    }
                }
                
                return bestVoice;
            }
            
            // Find the best voice using enhanced matching
            const bestVoice = findBestVoice(voices, selectedVoice, targetLang, preferredGender, voiceName);
            
            if (bestVoice) {
                currentUtterance.voice = bestVoice;
                console.log(`üé§ SELECTED VOICE: ${bestVoice.name} (${bestVoice.lang}) for request: ${selectedVoice}`);
                
                // Verify the voice was actually set
                setTimeout(() => {
                    if (currentUtterance.voice) {
                        console.log(`‚úÖ Voice confirmed set: ${currentUtterance.voice.name}`);
                    } else {
                        console.warn('‚ö†Ô∏è Voice was not set properly');
                    }
                }, 100);
                
                // Android-specific voice information
                if (browserInfo.isAndroid) {
                    console.log(`ü§ñ Android voice system: ${voices.length} total voices available`);
                    console.log(`ü§ñ ACTUALLY USING: ${bestVoice.name} (${bestVoice.lang})`);
                    
                    // Show quick notification with actual voice being used
                    const quickNotice = document.createElement('div');
                    quickNotice.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        background: #28a745;
                        color: white;
                        padding: 8px 15px;
                        border-radius: 4px;
                        font-size: 13px;
                        z-index: 10000;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                        max-width: 300px;
                    `;
                    quickNotice.innerHTML = `üé§ Using: ${bestVoice.name}`;
                    document.body.appendChild(quickNotice);
                    
                    setTimeout(() => {
                        if (document.body.contains(quickNotice)) {
                            quickNotice.remove();
                        }
                    }, 4000);
                }
            } else {
                console.error('‚ùå No voice could be selected!');
                updateTTSStatus('idle', 'No suitable voice found');
            }

            currentUtterance.onstart = function() {
                updateTTSStatus('processing', 'Speaking...');
                speakBtn.disabled = true;
                stopSpeechBtn.disabled = false;
            };

            currentUtterance.onend = function() {
                updateTTSStatus('success', 'Speech completed');
                speakBtn.disabled = false;
                stopSpeechBtn.disabled = true;
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
            };

            currentUtterance.onerror = function(event) {
                console.error('üî¥ TTS Error:', event);
                
                let errorMessage = 'Speech error occurred';
                let suggestion = '';
                
                if (event.error) {
                    switch(event.error) {
                        case 'not-allowed':
                            errorMessage = 'Speech synthesis not allowed';
                            suggestion = 'Check browser permissions for audio playback';
                            break;
                        case 'network':
                            errorMessage = 'Network error during speech';
                            suggestion = 'Check your internet connection';
                            break;
                        case 'synthesis-failed':
                            errorMessage = 'Voice synthesis failed';
                            suggestion = 'Try a different voice or shorter text';
                            break;
                        case 'audio-hardware':
                            errorMessage = 'Audio hardware error';
                            suggestion = 'Check your speakers/headphones';
                            break;
                        default:
                            errorMessage = `TTS error: ${event.error}`;
                            suggestion = 'Try refreshing the page';
                    }
                }
                
                updateTTSStatus('idle', errorMessage);
                
                if (suggestion) {
                    console.log('üí° TTS Suggestion:', suggestion);
                    // Could show user notification here if needed
                }
                
                speakBtn.disabled = false;
                stopSpeechBtn.disabled = true;
            };

            speechSynthesis.speak(currentUtterance);
        });

        stopSpeechBtn.addEventListener('click', function() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
                updateTTSStatus('idle', 'Speech stopped');
                speakBtn.disabled = false;
                stopSpeechBtn.disabled = true;
            }
        });

        useTranscriptBtn.addEventListener('click', function() {
            const transcript = transcriptArea.textContent;
            if (transcript && transcript !== 'Your speech will appear here...') {
                textInput.value = transcript;
                updateTTSStatus('success', 'Transcript loaded for TTS');
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
            } else {
                alert('No transcript available. Please record some speech first.');
            }
        });

        saveAudioBtn.addEventListener('click', async function() {
            const text = textInput.value.trim();
            if (!text) {
                alert('Please enter text to save as audio');
                return;
            }

            const selectedVoice = voiceSelect.value;
            const rate = parseFloat(speechRateSlider.value);
            const volume = parseFloat(speechVolumeSlider.value);

            try {
                updateTTSStatus('processing', 'Generating audio file...');
                saveAudioBtn.disabled = true;

                // Call backend TTS API (works both locally and on Vercel)
                const apiEndpoint = window.location.hostname === 'localhost' ? '/tts' : '/api/tts';
                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        voice: selectedVoice,
                        rate: rate,
                        volume: volume
                    })
                });

                // Check if response is ok and has content
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const responseText = await response.text();
                if (!responseText.trim()) {
                    throw new Error('Empty response from server');
                }

                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (jsonError) {
                    console.error('JSON parse error:', jsonError);
                    console.error('Response text:', responseText);
                    throw new Error('Invalid JSON response from server');
                }

                if (result.success) {
                    updateTTSStatus('success', 'Audio downloaded successfully!');
                    
                    // Create download container with link and close button
                    const downloadContainer = document.createElement('div');
                    downloadContainer.className = 'download-container';
                    downloadContainer.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        margin-top: 10px;
                        padding: 10px;
                        background: rgba(99, 102, 241, 0.1);
                        border: 1px solid rgba(99, 102, 241, 0.3);
                        border-radius: 8px;
                        font-size: 14px;
                    `;
                    
                    const downloadLink = document.createElement('a');
                    
                    // Handle both local server (file URL) and Vercel (base64 data)
                    if (result.audio_url) {
                        // Local server response with file URL
                        downloadLink.href = result.audio_url;
                        downloadLink.download = result.filename;
                    } else if (result.audio_data) {
                        // Vercel serverless response with base64 data
                        const audioBlob = new Blob([
                            new Uint8Array(atob(result.audio_data).split('').map(c => c.charCodeAt(0)))
                        ], { type: 'audio/mpeg' });
                        downloadLink.href = URL.createObjectURL(audioBlob);
                        downloadLink.download = `tts_audio_${Date.now()}.mp3`;
                    }
                    
                    downloadLink.textContent = `üíæ ${downloadLink.download}`;
                    downloadLink.style.cssText = `
                        color: #6366f1;
                        text-decoration: none;
                        font-weight: 500;
                        cursor: pointer;
                    `;
                    
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '‚úï';
                    closeButton.style.cssText = `
                        background: none;
                        border: none;
                        color: #6366f1;
                        cursor: pointer;
                        font-size: 16px;
                        padding: 0;
                        width: 20px;
                        height: 20px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    downloadContainer.appendChild(downloadLink);
                    downloadContainer.appendChild(closeButton);
                    
                    // Add download container to the interface
                    const existingContainer = document.querySelector('.download-container');
                    if (existingContainer) {
                        existingContainer.remove();
                    }
                    
                    saveAudioBtn.parentNode.appendChild(downloadContainer);
                    
                    // Add click handlers
                    downloadLink.addEventListener('click', function() {
                        console.log('üéµ Audio download started');
                        setTimeout(() => {
                            if (document.body.contains(downloadContainer)) {
                                downloadContainer.remove();
                                console.log('üóëÔ∏è Download container removed after download');
                            }
                        }, 3000); // Remove after 3 seconds to allow download to complete
                    });
                    
                    closeButton.addEventListener('click', function() {
                        downloadContainer.remove();
                        console.log('üóëÔ∏è Download container manually closed');
                    });
                    
                    // Auto-download
                    downloadLink.click();
                    
                    // Fallback removal after 10 seconds
                    setTimeout(() => {
                        if (document.body.contains(downloadContainer)) {
                            downloadContainer.remove();
                            console.log('üóëÔ∏è Download container removed (fallback)');
                        }
                        updateTTSStatus('idle', 'Ready to Speak');
                    }, 10000);
                } else {
                    updateTTSStatus('idle', 'Error: ' + (result.error || 'Failed to generate audio'));
                    alert('Failed to generate audio: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                updateTTSStatus('idle', 'Network error occurred');
                console.error('TTS API Error:', error);
                
                let errorMessage = 'Error generating audio: ' + error.message;
                
                // Check for specific error types
                if (error.message.includes('405') || error.message.includes('Method Not Allowed')) {
                    errorMessage = '‚ùå Backend Server Required!\n\n' +
                                 'You are using a static file server (like VS Code Live Server).\n' +
                                 'Audio generation requires the Python backend server.\n\n' +
                                 'Please:\n' +
                                 '1. Close this tab\n' +
                                 '2. Run: python tts_backend.py\n' +
                                 '3. Open: http://localhost:8000\n\n' +
                                 'The static server cannot handle TTS requests.';
                } else if (error.message.includes('fetch')) {
                    errorMessage = '‚ùå Backend server not running.\n\n' +
                                 'Please start the server with: python tts_backend.py\n' +
                                 'Then access: http://localhost:8000';
                } else if (error.message.includes('JSON')) {
                    errorMessage = '‚ùå Server response error.\n\n' +
                                 'The server returned invalid data.\n' +
                                 'Check the server console for details.';
                }
                
                alert(errorMessage);
            } finally {
                saveAudioBtn.disabled = false;
            }
        });

        // Utility Functions
        function updateSTTStatus(type, message) {
            const icon = sttStatus.querySelector('i');
            const text = sttStatus.querySelector('span');
            
            sttStatus.className = `status-indicator status-${type}`;
            text.textContent = message;
            
            switch(type) {
                case 'recording':
                    icon.className = 'fas fa-microphone';
                    break;
                case 'processing':
                    icon.className = 'fas fa-spinner fa-spin';
                    break;
                case 'success':
                    icon.className = 'fas fa-check';
                    break;
                default:
                    icon.className = 'fas fa-circle';
            }
        }

        function updateTTSStatus(type, message) {
            const icon = ttsStatus.querySelector('i');
            const text = ttsStatus.querySelector('span');
            
            ttsStatus.className = `status-indicator status-${type}`;
            text.textContent = message;
            
            switch(type) {
                case 'processing':
                    icon.className = 'fas fa-spinner fa-spin';
                    break;
                case 'success':
                    icon.className = 'fas fa-check';
                    break;
                default:
                    icon.className = 'fas fa-circle';
            }
        }

        function resetRecording() {
            isRecording = false;
            isRecordingDiv.textContent = 'Recording: False';
            recordBtn.disabled = false;
            stopBtn.disabled = true;
            waveAnimation.style.display = 'none';
        }

        // Enhanced voice loading with browser compatibility
        let voicesLoaded = false;
        let availableVoices = [];
        let voiceLoadAttempts = 0;
        const maxVoiceLoadAttempts = 10;
        
        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            voiceLoadAttempts++;
            
            if (voices.length > 0 && !voicesLoaded) {
                voicesLoaded = true;
                availableVoices = voices;
                
                console.log(`üé§ Loaded ${voices.length} system voices:`, 
                    voices.map(v => `${v.name} (${v.lang})`));
                
                // Group voices by language for better organization
                const voicesByLang = {};
                voices.forEach(voice => {
                    const lang = voice.lang.split('-')[0];
                    if (!voicesByLang[lang]) voicesByLang[lang] = [];
                    voicesByLang[lang].push(voice);
                });
                
                console.log('üåê Voices by language:', voicesByLang);
                
                updateTTSStatus('success', `Voice system ready (${voices.length} voices)`);
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
                
                return true;
            } else if (voiceLoadAttempts < maxVoiceLoadAttempts) {
                // Keep trying to load voices
                setTimeout(loadVoices, 500);
            } else {
                console.warn('‚ö†Ô∏è Could not load system voices after maximum attempts');
                updateTTSStatus('idle', 'Limited voice support available');
            }
            
            return false;
        }
        
        // Enhanced voice change event handling for different browsers
        if ('onvoiceschanged' in speechSynthesis) {
            speechSynthesis.onvoiceschanged = loadVoices;
        }
        
        // Immediate load attempt
        loadVoices();
        
        // Browser-specific loading strategies
        if (browserInfo.isAndroid) {
            // Android browsers need more aggressive voice loading
            console.log('ü§ñ Android voice loading strategy activated');
            setTimeout(loadVoices, 500);
            setTimeout(loadVoices, 1500);
            setTimeout(loadVoices, 3000);
            setTimeout(loadVoices, 5000); // Android sometimes takes longer
            
            // Force voice loading on user interaction for Android
            document.addEventListener('touchstart', loadVoices, { once: true });
            document.addEventListener('click', loadVoices, { once: true });
        } else if (browserInfo.isChrome || browserInfo.isEdge) {
            // Chrome/Edge typically loads voices asynchronously
            setTimeout(loadVoices, 100);
            setTimeout(loadVoices, 500);
        } else if (browserInfo.isFirefox) {
            // Firefox might need more time
            setTimeout(loadVoices, 1000);
            setTimeout(loadVoices, 2000);
        } else if (browserInfo.isSafari) {
            // Safari has different timing
            setTimeout(loadVoices, 200);
            setTimeout(loadVoices, 1500);
        }
        
        // Universal fallback
        setTimeout(loadVoices, 3000);

        // Clear transcript function
        function clearTranscript() {
            transcriptArea.textContent = 'Your speech will appear here...';
            transcriptArea.dataset.finalText = '';
            textInput.value = '';
        }
        
        // Enhanced voice change listener with Android-specific feedback
        voiceSelect.addEventListener('change', function() {
            const selectedVoice = this.value;
            const voiceName = selectedVoice.split('-')[2]?.replace('Neural', '') || selectedVoice;
            
            console.log(`üé§ Voice selection changed to: ${selectedVoice}`);
            
            if (browserInfo.isAndroid) {
                // For Android, show which system voice will actually be used
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    // Simulate the voice matching to show user what will be used
                    const targetLang = selectedVoice.includes('en-US') ? 'en-US' : 
                                     selectedVoice.includes('en-GB') ? 'en-GB' : 
                                     selectedVoice.includes('en-IN') ? 'en-IN' : 'en-US';
                    
                    const preferredGender = maleVoices.some(name => selectedVoice.toLowerCase().includes(name)) ? 'male' : 'female';
                    
                    // Find what voice will actually be used
                    const matchedVoice = voices.find(voice => {
                        const score = (voice.lang === targetLang ? 100 : 
                                     voice.lang.startsWith(targetLang.split('-')[0]) ? 70 : 0) +
                                    (preferredGender === 'male' && 
                                     (maleVoices.some(male => voice.name.toLowerCase().includes(male)) || 
                                      voice.name.toLowerCase().includes('male')) ? 50 : 0) +
                                    (preferredGender === 'female' && 
                                     (femaleVoices.some(female => voice.name.toLowerCase().includes(female)) || 
                                      voice.name.toLowerCase().includes('female')) ? 50 : 0);
                        return score > 50;
                    }) || voices[0];
                    
                    updateTTSStatus('success', `${voiceName} ‚Üí ${matchedVoice.name}`);
                    console.log(`ü§ñ Android will use system voice: ${matchedVoice.name} for ${selectedVoice}`);
                } else {
                    updateTTSStatus('success', `Voice changed to ${voiceName} (Android)`);
                }
            } else {
                updateTTSStatus('success', `Voice changed to ${voiceName}`);
            }
            
            setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 3000);
        });

        // Test voice button for Android users
        testVoiceBtn.addEventListener('click', function() {
            const selectedVoice = voiceSelect.value;
            const testText = `Testing voice ${selectedVoice.split('-')[2]?.replace('Neural', '') || 'selection'}`;
            
            console.log(`üß™ Testing voice: ${selectedVoice}`);
            
            // Create a quick test utterance
            const testUtterance = new SpeechSynthesisUtterance(testText);
            testUtterance.rate = 1.0;
            testUtterance.volume = 0.8;
            
            // Apply the same voice selection logic
            const voices = speechSynthesis.getVoices();
            if (voices.length > 0) {
                const targetLang = selectedVoice.includes('en-US') ? 'en-US' : 
                                 selectedVoice.includes('en-GB') ? 'en-GB' : 
                                 selectedVoice.includes('en-IN') ? 'en-IN' : 'en-US';
                const preferredGender = maleVoices.some(name => selectedVoice.toLowerCase().includes(name)) ? 'male' : 'female';
                const voiceName = selectedVoice.match(/en-[A-Z]{2}-([A-Za-z]+)Neural/)?.[1]?.toLowerCase() || '';
                
                const testVoice = findBestVoice(voices, selectedVoice, targetLang, preferredGender, voiceName);
                if (testVoice) {
                    testUtterance.voice = testVoice;
                    console.log(`üß™ Test using: ${testVoice.name} (${testVoice.lang})`);
                }
            }
            
            testUtterance.onstart = () => {
                updateTTSStatus('processing', 'Testing voice...');
                testVoiceBtn.disabled = true;
            };
            
            testUtterance.onend = () => {
                updateTTSStatus('success', 'Voice test completed');
                testVoiceBtn.disabled = false;
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
            };
            
            testUtterance.onerror = (event) => {
                updateTTSStatus('idle', 'Voice test failed');
                testVoiceBtn.disabled = false;
                console.error('üß™ Voice test error:', event.error);
            };
            
            speechSynthesis.speak(testUtterance);
        });

        // Voice cycling feature for Android to test different voices
        let currentVoiceIndex = 0;
        cycleVoicesBtn.addEventListener('click', function() {
            const voices = speechSynthesis.getVoices();
            if (voices.length === 0) {
                updateTTSStatus('idle', 'No voices available');
                return;
            }
            
            // Use a subset of voices for cycling (first 20 to avoid overwhelming)
            const cyclableVoices = voices.slice(0, Math.min(20, voices.length));
            const voice = cyclableVoices[currentVoiceIndex];
            currentVoiceIndex = (currentVoiceIndex + 1) % cyclableVoices.length;
            
            const testText = `Voice ${currentVoiceIndex}: ${voice.name}`;
            console.log(`üîÑ Cycling to voice ${currentVoiceIndex}: ${voice.name} (${voice.lang})`);
            
            const utterance = new SpeechSynthesisUtterance(testText);
            utterance.voice = voice;
            utterance.rate = 1.0;
            utterance.volume = 0.8;
            
            utterance.onstart = () => {
                updateTTSStatus('processing', `Testing: ${voice.name}`);
                cycleVoicesBtn.disabled = true;
            };
            
            utterance.onend = () => {
                updateTTSStatus('success', `Voice ${currentVoiceIndex}/${cyclableVoices.length}: ${voice.name}`);
                cycleVoicesBtn.disabled = false;
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 3000);
            };
            
            utterance.onerror = (event) => {
                updateTTSStatus('idle', `Error with voice: ${voice.name}`);
                cycleVoicesBtn.disabled = false;
                console.error('üîÑ Voice cycle error:', event.error);
            };
            
            speechSynthesis.speak(utterance);
        });

        // Comprehensive browser compatibility check and user guidance
        function showBrowserGuidance() {
            const guidance = document.createElement('div');
            guidance.id = 'browser-guidance';
            guidance.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                width: 320px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 14px;
                z-index: 9999;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            let content = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;"><strong>üåê Browser Compatibility</strong><button onclick="this.parentElement.parentElement.remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; border-radius: 50%; width: 24px; height: 24px; cursor: pointer;">‚úï</button></div>';
            
            if (browserInfo.isChrome) {
                content += '<div style="margin-bottom: 8px;">‚úÖ <strong>Chrome:</strong> Full support</div>';
                content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ‚úÖ<br>‚Ä¢ Voice Synthesis: ‚úÖ<br>‚Ä¢ All features working</div>';
            } else if (browserInfo.isEdge) {
                content += '<div style="margin-bottom: 8px;">‚úÖ <strong>Edge:</strong> Full support</div>';
                content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ‚úÖ<br>‚Ä¢ Voice Synthesis: ‚úÖ<br>‚Ä¢ All features working</div>';
            } else if (browserInfo.isFirefox) {
                content += '<div style="margin-bottom: 8px;">‚ö†Ô∏è <strong>Firefox:</strong> Limited support</div>';
                content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: May need enabling<br>‚Ä¢ Voice Synthesis: ‚úÖ<br>‚Ä¢ Type <code>about:config</code> and enable <code>media.webspeech.recognition.enable</code></div>';
            } else if (browserInfo.isSafari) {
                content += '<div style="margin-bottom: 8px;">‚ö†Ô∏è <strong>Safari:</strong> Partial support</div>';
                content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: Limited<br>‚Ä¢ Voice Synthesis: ‚úÖ<br>‚Ä¢ Best experience in iOS 14.5+</div>';
            } else if (browserInfo.isAndroid) {
                if (browserInfo.isAndroidChrome) {
                    content += '<div style="margin-bottom: 8px;">üì± <strong>Android Chrome:</strong> Good support</div>';
                    content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ‚úÖ<br>‚Ä¢ Voice Synthesis: Limited voices<br>‚Ä¢ Uses system TTS voices</div>';
                } else if (browserInfo.isAndroidSamsung) {
                    content += '<div style="margin-bottom: 8px;">üì± <strong>Samsung Browser:</strong> Basic support</div>';
                    content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ‚úÖ<br>‚Ä¢ Voice Synthesis: System voices only<br>‚Ä¢ Consider using Chrome</div>';
                } else {
                    content += '<div style="margin-bottom: 8px;">üì± <strong>Android Browser:</strong> Limited support</div>';
                    content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: May work<br>‚Ä¢ Voice Synthesis: Basic<br>‚Ä¢ Recommend Chrome for Android</div>';
                }
            } else {
                content += '<div style="margin-bottom: 8px;">‚ùì <strong>Other Browser</strong></div>';
                content += '<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ For best experience, use Chrome or Edge<br>‚Ä¢ Some features may not work</div>';
            }
            
            guidance.innerHTML = content;
            document.body.appendChild(guidance);
            
            // Animate in
            setTimeout(() => {
                guidance.style.opacity = '1';
                guidance.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto-hide after 8 seconds
            setTimeout(() => {
                if (document.body.contains(guidance)) {
                    guidance.style.opacity = '0';
                    guidance.style.transform = 'translateX(100%)';
                    setTimeout(() => guidance.remove(), 300);
                }
            }, 8000);
        }

        // Feature detection and capability reporting
        function checkFeatureSupport() {
            const features = {
                speechRecognition: !!(window.SpeechRecognition || window.webkitSpeechRecognition),
                speechSynthesis: !!window.speechSynthesis,
                mediaDevices: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                audioContext: !!(window.AudioContext || window.webkitAudioContext),
                webAudio: 'AudioContext' in window || 'webkitAudioContext' in window
            };
            
            console.log('üîç Feature Support:', features);
            
            // Show warnings for missing features
            if (!features.speechRecognition) {
                updateSTTStatus('idle', 'Speech Recognition not supported');
            }
            
            if (!features.speechSynthesis) {
                updateTTSStatus('idle', 'Speech Synthesis not supported');
            }
            
            if (!features.mediaDevices) {
                console.warn('‚ö†Ô∏è Media Devices API not available');
            }
            
            return features;
        }

        // Initialize feature support checking
        const supportedFeatures = checkFeatureSupport();
        
        // Show browser guidance on page load
        setTimeout(showBrowserGuidance, 2000);

        // Check if we're running on the correct Python backend server
        async function checkServerType() {
            try {
                const response = await fetch('/test', { method: 'GET' });
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === "Server is running") {
                        console.log('‚úÖ Connected to Python TTS backend server');
                        return true;
                    }
                }
            } catch (error) {
                // Likely using a static file server
                const currentUrl = window.location.href;
                if (currentUrl.includes('127.0.0.1:5500') || 
                    currentUrl.includes('localhost:5500') ||
                    currentUrl.includes('liveserver') ||
                    !currentUrl.includes('localhost:8000')) {
                    
                    // Show warning for static file server users
                    const warningDiv = document.createElement('div');
                    warningDiv.innerHTML = `
                        <div style="position: fixed; top: 0; left: 0; right: 0; z-index: 10000; 
                                    background: linear-gradient(45deg, #ff6b6b, #ee5a24); 
                                    color: white; padding: 15px; text-align: center; 
                                    font-family: Arial, sans-serif; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
                            <strong>‚ö†Ô∏è Static File Server Detected!</strong><br>
                            <span style="font-size: 14px;">
                                For full TTS functionality, please run: <code>python tts_backend.py</code> 
                                and access <code>http://localhost:8000</code>
                            </span>
                            <button onclick="this.parentElement.parentElement.remove()" 
                                    style="margin-left: 10px; background: rgba(255,255,255,0.2); 
                                           border: 1px solid white; color: white; padding: 5px 10px; 
                                           border-radius: 3px; cursor: pointer;">‚úï</button>
                        </div>
                    `;
                    document.body.appendChild(warningDiv);
                }
                return false;
            }
        }

        // Cleanup temporary files on page load
        async function cleanupTempFiles() {
            try {
                const response = await fetch('/cleanup', { method: 'GET' });
                if (response.ok) {
                    const result = await response.json();
                    if (result.cleaned_files > 0) {
                        console.log(`üßπ Cleaned up ${result.cleaned_files} temporary files`);
                    }
                }
            } catch (error) {
                console.log('Note: Could not clean up temporary files (server may not be running)');
            }
        }

        // Check server type and cleanup on page load
        checkServerType();
        cleanupTempFiles();
        window.addEventListener('beforeunload', cleanupTempFiles);

        // Final initialization and compatibility summary
        function initializeApp() {
            console.log('üöÄ Initializing Speech Processing Suite...');
            console.log('üìä Browser Compatibility Summary:', {
                browser: browserInfo,
                features: supportedFeatures,
                speechRecognitionReady: !!recognition,
                voicesLoaded: voicesLoaded,
                availableVoicesCount: availableVoices.length
            });
            
            // Set initial status messages
            if (supportedFeatures.speechRecognition && recognition) {
                updateSTTStatus('idle', 'Ready to Listen');
            } else {
                updateSTTStatus('idle', 'Speech Recognition unavailable');
            }
            
            if (supportedFeatures.speechSynthesis) {
                updateTTSStatus('idle', 'Ready to Speak');
            } else {
                updateTTSStatus('idle', 'Speech Synthesis unavailable');
            }
            
            // Log final compatibility status
            const compatibilityScore = [
                supportedFeatures.speechRecognition ? 25 : 0,
                supportedFeatures.speechSynthesis ? 25 : 0,
                supportedFeatures.mediaDevices ? 25 : 0,
                (browserInfo.isChrome || browserInfo.isEdge) ? 25 : 
                (browserInfo.isAndroidChrome) ? 20 :
                (browserInfo.isAndroid) ? 15 :
                (browserInfo.isFirefox || browserInfo.isSafari) ? 15 : 5
            ].reduce((a, b) => a + b, 0);
            
            console.log(`‚ú® App initialized with ${compatibilityScore}% compatibility`);
            
            if (compatibilityScore < 50) {
                console.warn('‚ö†Ô∏è Low compatibility detected. Some features may not work properly.');
            }
            
            // Show test voice and cycle buttons for Android users
            if (browserInfo.isAndroid && supportedFeatures.speechSynthesis) {
                testVoiceBtn.style.display = 'inline-block';
                cycleVoicesBtn.style.display = 'inline-block';
                console.log('ü§ñ Test voice and cycle buttons enabled for Android');
            }
        }
        
        // Initialize the app
        setTimeout(initializeApp, 1000);
    </script>
</body>
</html>