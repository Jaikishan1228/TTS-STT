<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced Speech Processing Suite - Convert Speech to Text and Text to Speech with Neural Voices">
    <meta name="keywords" content="speech to text, text to speech, TTS, STT, voice recognition, neural voices">
    <meta name="author" content="Jay">
    <title>STT & TTS - Speech Processing</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/icons8-favorite-48.png">
    <link rel="shortcut icon" type="image/png" href="assets/icons8-favorite-48.png">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="css/inter-font.css">
    <link rel="stylesheet" href="css/fontawesome.css">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/fallbacks.css">
    
    <!-- Mobile-specific enhancements -->
    <style>
        /* Mobile-specific improvements */
        @media (max-width: 768px) {
            .btn {
                min-height: 48px !important; /* Better touch targets */
                font-size: 16px !important; /* Prevent zoom on iOS */
                padding: 12px 20px !important;
                margin: 8px 4px !important;
            }
            
            .record-btn {
                min-height: 60px !important;
                width: 100% !important;
                max-width: 300px !important;
                font-size: 18px !important;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            }
            
            textarea {
                font-size: 16px !important; /* Prevent zoom on iOS */
                min-height: 120px !important;
                touch-action: manipulation;
            }
            
            input, select {
                font-size: 16px !important; /* Prevent zoom on iOS */
                min-height: 44px !important;
            }
            
            .container {
                padding: 10px !important;
            }
            
            /* iOS-specific fixes */
            .ios-device * {
                -webkit-user-select: none;
                user-select: none;
                -webkit-touch-callout: none;
                -webkit-tap-highlight-color: transparent;
            }
            
            .ios-device input, .ios-device textarea {
                -webkit-user-select: text;
                user-select: text;
            }
            
            /* Android-specific optimizations */
            .android-device .record-btn {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            }
            
            .android-device .record-btn:active {
                transform: scale(0.95);
                transition: transform 0.1s;
            }
        }
        
        /* Touch-friendly wave animation for mobile */
        @media (max-width: 768px) {
            .wave-animation {
                transform: scale(1.2);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéôÔ∏è STT & TTS</h1>
        <p>Advanced Speech Processing - Convert Speech to Text and Text to Speech</p>
    </div>

    <div class="container">
        <!-- Speech to Text Section -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-microphone"></i>
                <h2>Speech to Text</h2>
            </div>

            <div class="status-indicator" id="stt_status">
                <i class="fas fa-circle"></i>
                <span>Ready to Listen</span>
            </div>

            <div class="form-group">
                <label for="language_select">Recognition Language</label>
                <select id="language_select" class="form-control">
                    <option value="en-US">English (US)</option>
                    <option value="en-GB">English (UK)</option>
                    <option value="en-AU">English (Australia)</option>
                    <option value="en-CA">English (Canada)</option>
                    <option value="en-IN">English (India)</option>
                    <option value="es-ES">Spanish (Spain)</option>
                    <option value="es-MX">Spanish (Mexico)</option>
                    <option value="fr-FR">French (France)</option>
                    <option value="fr-CA">French (Canada)</option>
                    <option value="de-DE">German (Germany)</option>
                    <option value="it-IT">Italian (Italy)</option>
                    <option value="pt-BR">Portuguese (Brazil)</option>
                    <option value="pt-PT">Portuguese (Portugal)</option>
                    <option value="ru-RU">Russian (Russia)</option>
                    <option value="ja-JP">Japanese (Japan)</option>
                    <option value="ko-KR">Korean (Korea)</option>
                    <option value="zh-CN">Chinese (Mandarin)</option>
                    <option value="zh-TW">Chinese (Traditional)</option>
                    <option value="ar-SA">Arabic (Saudi Arabia)</option>
                    <option value="hi-IN">Hindi (India)</option>
                    <option value="th-TH">Thai (Thailand)</option>
                    <option value="vi-VN">Vietnamese (Vietnam)</option>
                    <option value="nl-NL">Dutch (Netherlands)</option>
                    <option value="sv-SE">Swedish (Sweden)</option>
                    <option value="da-DK">Danish (Denmark)</option>
                    <option value="no-NO">Norwegian (Norway)</option>
                    <option value="fi-FI">Finnish (Finland)</option>
                    <option value="pl-PL">Polish (Poland)</option>
                    <option value="cs-CZ">Czech (Czech Republic)</option>
                    <option value="hu-HU">Hungarian (Hungary)</option>
                    <option value="ro-RO">Romanian (Romania)</option>
                    <option value="bg-BG">Bulgarian (Bulgaria)</option>
                    <option value="hr-HR">Croatian (Croatia)</option>
                    <option value="sk-SK">Slovak (Slovakia)</option>
                    <option value="sl-SI">Slovenian (Slovenia)</option>
                    <option value="et-EE">Estonian (Estonia)</option>
                    <option value="lv-LV">Latvian (Latvia)</option>
                    <option value="lt-LT">Lithuanian (Lithuania)</option>
                    <option value="mt-MT">Maltese (Malta)</option>
                </select>
            </div>

            <div class="btn-group">
                <button id="click_to_record" class="btn btn-primary">
                    <i class="fas fa-microphone"></i>
                    Start Recording
                </button>
                <button id="stop_recording" class="btn btn-danger" disabled>
                    <i class="fas fa-stop"></i>
                    Stop Recording
                </button>
                <button id="clear_transcript" class="btn btn-warning">
                    <i class="fas fa-trash"></i>
                    Clear
                </button>
            </div>

            <div class="form-group">
                <label>Transcription Output</label>
                <div class="output-area">
                    <div id="convert_text" class="transcript-text">Your speech will appear here...</div>
                </div>
            </div>

            <div id="wave_animation" class="wave-animation" style="display: none;">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>

            <!-- Hidden status element for Python integration -->
            <div id="is_recording" style="display: none;">Recording: False</div>
        </div>

        <!-- Text to Speech Section -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-volume-up"></i>
                <h2>Text to Speech</h2>
            </div>

            <div class="status-indicator" id="tts_status">
                <i class="fas fa-circle"></i>
                <span>Ready to Speak</span>
            </div>

            <div class="form-group">
                <label for="tts_voice_select">Voice Selection</label>
                <select id="tts_voice_select" class="form-control">
                    <option value="en-US-JennyNeural">Jenny (US) - Friendly Female</option>
                    <option value="en-US-GuyNeural">Guy (US) - Friendly Male</option>
                    <option value="en-US-AriaNeural">Aria (US) - News Female</option>
                    <option value="en-US-DavisNeural">Davis (US) - News Male</option>
                    <option value="en-US-AmberNeural">Amber (US) - Warm Female</option>
                    <option value="en-US-AnaNeural">Ana (US) - Child Female</option>
                    <option value="en-US-BrandonNeural">Brandon (US) - Young Male</option>
                    <option value="en-US-ChristopherNeural">Christopher (US) - Professional Male</option>
                    <option value="en-US-CoraNeural">Cora (US) - Mature Female</option>
                    <option value="en-US-ElizabethNeural">Elizabeth (US) - Calm Female</option>
                    <option value="en-US-EricNeural">Eric (US) - Casual Male</option>
                    <option value="en-US-JacobNeural">Jacob (US) - Conversational Male</option>
                    <option value="en-US-JaneNeural">Jane (US) - Clear Female</option>
                    <option value="en-US-JasonNeural">Jason (US) - Energetic Male</option>
                    <option value="en-US-MichelleNeural">Michelle (US) - Expressive Female</option>
                    <option value="en-US-MonicaNeural">Monica (US) - Pleasant Female</option>
                    <option value="en-US-NancyNeural">Nancy (US) - Storyteller Female</option>
                    <option value="en-US-RogerNeural">Roger (US) - Deep Male</option>
                    <option value="en-US-SaraNeural">Sara (US) - Gentle Female</option>
                    <option value="en-US-SteffanNeural">Steffan (US) - Warm Male</option>
                    <option value="en-GB-SoniaNeural">Sonia (UK) - British Female</option>
                    <option value="en-GB-RyanNeural">Ryan (UK) - British Male</option>
                    <option value="en-AU-NatashaNeural">Natasha (AU) - Australian Female</option>
                    <option value="en-AU-WilliamNeural">William (AU) - Australian Male</option>
                    <option value="en-CA-ClaraNeural">Clara (CA) - Canadian Female</option>
                    <option value="en-CA-LiamNeural">Liam (CA) - Canadian Male</option>
                    <option value="en-IN-NeerjaNeural">Neerja (IN) - Indian Female</option>
                    <option value="en-IN-PrabhatNeural">Prabhat (IN) - Indian Male</option>
                </select>
            </div>

            <div class="range-group">
                <div class="range-control">
                    <label for="speech_rate">Speech Rate</label>
                    <input type="range" id="speech_rate" min="0.5" max="2.0" value="1.0" step="0.1">
                    <div class="range-value" id="rate_value">1.0x</div>
                </div>
                <div class="range-control">
                    <label for="speech_volume">Volume</label>
                    <input type="range" id="speech_volume" min="0.0" max="1.0" value="0.8" step="0.1">
                    <div class="range-value" id="volume_value">80%</div>
                </div>
            </div>

            <div class="form-group">
                <label for="text_input">Text to Convert</label>
                <textarea id="text_input" class="form-control" rows="4" placeholder="Enter text to convert to speech..."></textarea>
            </div>

            <div class="btn-group">
                <button id="speak_text" class="btn btn-success">
                    <i class="fas fa-play"></i>
                    Speak Text
                </button>
                <button id="stop_speech" class="btn btn-danger" disabled>
                    <i class="fas fa-stop"></i>
                    Stop Speech
                </button>
                <button id="save_audio" class="btn btn-primary">
                    <i class="fas fa-download"></i>
                    Save Audio
                </button>
                <button id="use_transcript" class="btn btn-warning">
                    <i class="fas fa-arrow-left"></i>
                    Use Transcript
                </button>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Made with ‚ù§Ô∏è by <a href="https://github.com/Jaikishan1228" target="_blank">Jay</a> | 
        <a href="https://github.com/Jaikishan1228/TTS-STT" target="_blank">GitHub Repository</a></p>
    </div>

    <script>
        // Configuration
        const DEBUG_MODE = false; // Set to true for debugging
        
        // Debug logging wrapper
        const debugLog = (...args) => {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        };
        
        // Global variables
        let recognition = null;
        let isRecording = false;
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let recognitionActive = false;

        // DOM Elements
        const sttStatus = document.getElementById('stt_status');
        const ttsStatus = document.getElementById('tts_status');
        const recordBtn = document.getElementById('click_to_record');
        const stopBtn = document.getElementById('stop_recording');
        const clearBtn = document.getElementById('clear_transcript');
        const transcriptArea = document.getElementById('convert_text');
        const isRecordingDiv = document.getElementById('is_recording');
        const waveAnimation = document.getElementById('wave_animation');
        const languageSelect = document.getElementById('language_select');
        
        const voiceSelect = document.getElementById('tts_voice_select');
        const speechRateSlider = document.getElementById('speech_rate');
        const speechVolumeSlider = document.getElementById('speech_volume');
        const rateValue = document.getElementById('rate_value');
        const volumeValue = document.getElementById('volume_value');
        const textInput = document.getElementById('text_input');
        const speakBtn = document.getElementById('speak_text');
        const stopSpeechBtn = document.getElementById('stop_speech');
        const saveAudioBtn = document.getElementById('save_audio');
        const useTranscriptBtn = document.getElementById('use_transcript');

        // Enhanced browser compatibility check
        function checkBrowserSupport() {
            const userAgent = navigator.userAgent;
            const isChrome = /Chrome/.test(userAgent) && /Google Inc/.test(navigator.vendor) && !/OPR/.test(userAgent);
            const isEdge = /Edg/.test(userAgent);
            const isFirefox = /Firefox/.test(userAgent);
            const isSafari = /Safari/.test(userAgent) && !/Chrome/.test(userAgent);
            const isOpera = /OPR/.test(userAgent) || /Opera/.test(userAgent);
            
            // Mobile device detection
            const isAndroid = /Android/.test(userAgent);
            const isIOS = /iPhone|iPad|iPod/.test(userAgent);
            const isMobile = isAndroid || isIOS || /Mobile/.test(userAgent);
            
            // Mobile browser specific detection
            const isAndroidChrome = isAndroid && isChrome;
            const isIOSSafari = isIOS && isSafari;
            const isIOSChrome = isIOS && isChrome;
            
            debugLog('üåê Browser detected:', {
                chrome: isChrome,
                edge: isEdge,
                firefox: isFirefox,
                safari: isSafari,
                opera: isOpera,
                android: isAndroid,
                ios: isIOS,
                mobile: isMobile,
                androidChrome: isAndroidChrome,
                iosSafari: isIOSSafari,
                iosChrome: isIOSChrome,
                userAgent: userAgent
            });
            
            return { 
                isChrome, isEdge, isFirefox, isSafari, isOpera,
                isAndroid, isIOS, isMobile, isAndroidChrome, isIOSSafari, isIOSChrome
            };
        }

        const browserInfo = checkBrowserSupport();

        // Apply mobile-specific CSS classes
        if (browserInfo.isMobile) {
            document.body.classList.add('mobile-device');
            if (browserInfo.isIOS) {
                document.body.classList.add('ios-device');
            } else if (browserInfo.isAndroid) {
                document.body.classList.add('android-device');
            }
        }

        // Initialize Speech Recognition with enhanced browser support
        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                try {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognition = new SpeechRecognition();
                    
                    // Enhanced configuration for better browser compatibility
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.lang = languageSelect.value;
                    recognition.maxAlternatives = 1;
                    
                    // Browser and platform-specific optimizations
                    if (browserInfo.isMobile) {
                        // Mobile devices need special handling
                        if (browserInfo.isAndroidChrome) {
                            // Android Chrome works well with Web Speech API
                            recognition.continuous = false; // Better for mobile battery
                            recognition.interimResults = true;
                            debugLog('üì± Android Chrome optimizations applied');
                        } else if (browserInfo.isIOSSafari) {
                            // iOS Safari has very limited support
                            recognition.continuous = false;
                            recognition.interimResults = false; // iOS Safari doesn't support interim results well
                            debugLog('üì± iOS Safari optimizations applied');
                        } else if (browserInfo.isIOSChrome) {
                            // iOS Chrome uses Safari's engine
                            recognition.continuous = false;
                            recognition.interimResults = false;
                            debugLog('üì± iOS Chrome optimizations applied');
                        } else {
                            // Other mobile browsers
                            recognition.continuous = false;
                            recognition.interimResults = false;
                            debugLog('üì± Generic mobile optimizations applied');
                        }
                    } else {
                        // Desktop browsers
                        if (browserInfo.isChrome || browserInfo.isEdge) {
                            recognition.continuous = true;
                            recognition.interimResults = true;
                        } else if (browserInfo.isFirefox) {
                            // Firefox has limited support, use more conservative settings
                            recognition.continuous = false;
                            recognition.interimResults = false;
                        } else if (browserInfo.isSafari) {
                            // Safari needs special handling
                            recognition.continuous = false;
                            recognition.interimResults = true;
                        }
                    }
                    
                    console.log('üé§ Speech Recognition initialized with language:', languageSelect.value);
                    return true;
                } catch (error) {
                    console.error('üî¥ Speech Recognition initialization failed:', error);
                    return false;
                }
            }
            return false;
        }

        // Initialize speech recognition
        const speechRecognitionSupported = initializeSpeechRecognition();

        if (speechRecognitionSupported && recognition) {
            recognition.onstart = function() {
                recognitionActive = true;
                updateSTTStatus('recording', 'Recording... Speak now!');
                isRecording = true;
                isRecordingDiv.textContent = 'Recording: True';
                recordBtn.disabled = true;
                stopBtn.disabled = false;
                waveAnimation.style.display = 'flex';
                debugLog('üé§ Speech recognition started');
            };

            recognition.onresult = function(event) {
                // Build complete transcript from ALL results (both final and interim)
                let completeTranscript = '';
                let finalTranscript = '';
                let interimTranscript = '';
                
                for (let i = 0; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Mobile-specific handling
                if (browserInfo.isMobile) {
                    // Mobile devices handle results differently
                    completeTranscript = finalTranscript + interimTranscript;
                    
                    // iOS devices often don't provide interim results well
                    if (browserInfo.isIOS && finalTranscript) {
                        completeTranscript = finalTranscript;
                        // Provide haptic feedback on iOS when text is recognized
                        if ('vibrate' in navigator) {
                            navigator.vibrate(25);
                        }
                    }
                } else {
                    // Desktop handling - same as before
                    completeTranscript = finalTranscript + interimTranscript;
                }

                // Clear placeholder text first
                if (transcriptArea.textContent === 'Your speech will appear here...' || 
                    transcriptArea.textContent === 'Listening...') {
                    transcriptArea.textContent = '';
                }

                // Display the complete transcript (no accumulation, just replace)
                transcriptArea.textContent = completeTranscript;
                
                // Auto-scroll to bottom
                transcriptArea.scrollTop = transcriptArea.scrollHeight;
                
                debugLog('üìù Current transcript:', completeTranscript);
                
                // Mobile-specific visual feedback
                if (browserInfo.isMobile && completeTranscript.trim()) {
                    transcriptArea.style.backgroundColor = '#f0f8ff';
                    setTimeout(() => {
                        transcriptArea.style.backgroundColor = '';
                    }, 300);
                }
            };

            recognition.onerror = function(event) {
                console.error('üî¥ Speech Recognition Error:', event.error, event);
                
                let errorMessage = 'Error: ';
                let userAction = '';
                
                switch(event.error) {
                    case 'not-allowed':
                        errorMessage += 'Microphone permission denied';
                        if (browserInfo.isMobile) {
                            if (browserInfo.isIOS) {
                                userAction = 'iOS: Go to Settings > Safari > Camera & Microphone > Allow';
                            } else if (browserInfo.isAndroid) {
                                userAction = 'Android: Tap the microphone icon in address bar and allow access';
                            } else {
                                userAction = 'Please allow microphone access in your mobile browser settings';
                            }
                        } else {
                            userAction = 'Please click the microphone icon in your browser\'s address bar and allow access';
                        }
                        break;
                    case 'no-speech':
                        errorMessage += 'No speech detected';
                        if (browserInfo.isMobile) {
                            userAction = 'Hold device closer and speak clearly into the microphone';
                        } else {
                            userAction = 'Please speak closer to your microphone and try again';
                        }
                        break;
                    case 'audio-capture':
                        errorMessage += 'Microphone error';
                        if (browserInfo.isMobile) {
                            userAction = 'Check if another app is using the microphone, then try again';
                        } else {
                            userAction = 'Check your microphone connection and browser permissions';
                        }
                        break;
                    case 'network':
                        errorMessage += 'Network error';
                        if (browserInfo.isMobile) {
                            userAction = 'Check your mobile data or WiFi connection';
                        } else {
                            userAction = 'Check your internet connection';
                        }
                        break;
                    case 'service-not-allowed':
                        errorMessage += 'Speech service not allowed';
                        if (browserInfo.isFirefox) {
                            userAction = 'Enable speech recognition in Firefox: about:config ‚Üí media.webspeech.recognition.enable ‚Üí true';
                        } else {
                            userAction = 'Try using Chrome or Edge for better compatibility';
                        }
                        break;
                    case 'bad-grammar':
                        errorMessage += 'Grammar error';
                        userAction = 'Try speaking more clearly';
                        break;
                    case 'language-not-supported':
                        errorMessage += 'Language not supported';
                        userAction = 'Try switching to English or another supported language';
                        break;
                    default:
                        errorMessage += event.error;
                        userAction = 'Try refreshing the page or using a different browser';
                }
                
                updateSTTStatus('idle', errorMessage);
                
                // Show detailed user guidance
                if (userAction) {
                    setTimeout(() => {
                        const helpDiv = document.createElement('div');
                        helpDiv.style.cssText = `
                            position: fixed;
                            bottom: 20px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: #ff6b6b;
                            color: white;
                            padding: 15px 20px;
                            border-radius: 8px;
                            max-width: 400px;
                            text-align: center;
                            font-size: 14px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                        `;
                        helpDiv.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 8px;">üí° How to fix this:</div>
                            <div>${userAction}</div>
                            <button onclick="this.parentElement.remove()" style="margin-top: 10px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 5px 15px; border-radius: 4px; cursor: pointer;">Got it</button>
                        `;
                        document.body.appendChild(helpDiv);
                        
                        setTimeout(() => {
                            if (document.body.contains(helpDiv)) {
                                helpDiv.remove();
                            }
                        }, 10000);
                    }, 1000);
                }
                
                resetRecording();
            };

            recognition.onend = function() {
                recognitionActive = false;
                updateSTTStatus('success', 'Transcription completed');
                resetRecording();
                
                // Clear any stored transcript data to prevent accumulation on next session
                delete transcriptArea.dataset.finalText;
                
                debugLog('ÔøΩ Recognition session ended, transcript cleared for next session');
                
                setTimeout(() => updateSTTStatus('idle', 'Ready to Listen'), 2000);
            };


        } else {
            let errorMessage = 'Speech Recognition not supported in this browser';
            if (browserInfo.isFirefox) {
                errorMessage = 'Firefox: Enable speech recognition in about:config (media.webspeech.recognition.enable)';
            } else if (browserInfo.isSafari) {
                errorMessage = 'Safari: Speech Recognition has limited support';
            }
            updateSTTStatus('idle', errorMessage);
            recordBtn.disabled = true;
        }

        // Request microphone permission early with mobile-specific handling
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    console.log('üé§ Microphone permission granted');
                    stream.getTracks().forEach(track => track.stop()); // Stop the stream
                    
                    if (browserInfo.isMobile) {
                        updateSTTStatus('success', 'Tap to speak (Mobile)');
                        // Add mobile-specific instructions
                        setTimeout(() => {
                            if (browserInfo.isIOS) {
                                updateSTTStatus('idle', 'iOS: Hold button & speak clearly');
                            } else {
                                updateSTTStatus('idle', 'Android: Tap to start speaking');
                            }
                        }, 3000);
                    } else {
                        updateSTTStatus('success', 'Microphone ready');
                        setTimeout(() => updateSTTStatus('idle', 'Ready to Listen'), 2000);
                    }
                })
                .catch(function(err) {
                    console.warn('üî¥ Microphone permission denied:', err);
                    
                    if (browserInfo.isMobile) {
                        if (browserInfo.isIOS) {
                            updateSTTStatus('idle', 'iOS: Allow microphone in browser settings');
                        } else {
                            updateSTTStatus('idle', 'Android: Grant microphone permission');
                        }
                    } else {
                        updateSTTStatus('idle', 'Microphone permission needed');
                    }
                });
        }

        // Enhanced STT Event Listeners with browser compatibility
        recordBtn.addEventListener('click', async function(event) {
            event.preventDefault();
            
            if (!recognition) {
                updateSTTStatus('idle', 'Speech Recognition not available');
                return;
            }
            
            if (isRecording || recognitionActive) {
                updateSTTStatus('idle', 'Already recording');
                return;
            }

            try {
                // Clear any previous transcript data at the start of a new session
                transcriptArea.textContent = 'Listening...';
                delete transcriptArea.dataset.finalText;
                
                // Request microphone permission explicitly
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop()); // Stop the stream immediately
                        console.log('üé§ Microphone permission confirmed');
                    } catch (permissionError) {
                        updateSTTStatus('idle', 'Microphone permission denied');
                        alert('Please allow microphone access to use speech recognition');
                        return;
                    }
                }

                // Add delay for browser compatibility
                setTimeout(() => {
                    try {
                        recognition.start();
                        console.log('üé§ Speech recognition started');
                    } catch (startError) {
                        console.error('üî¥ Failed to start recognition:', startError);
                        updateSTTStatus('idle', 'Failed to start recording: ' + startError.message);
                        resetRecording();
                    }
                }, 100);
                
            } catch (error) {
                console.error('üî¥ Recording error:', error);
                updateSTTStatus('idle', 'Recording error: ' + error.message);
                resetRecording();
            }
        });

        stopBtn.addEventListener('click', function(event) {
            event.preventDefault();
            
            if (recognition && isRecording) {
                try {
                    recognition.stop();
                    console.log('üé§ Speech recognition stopped');
                } catch (stopError) {
                    console.error('üî¥ Failed to stop recognition:', stopError);
                    resetRecording();
                }
            }
        });

        // Mobile-specific touch event handling
        if (browserInfo.isMobile) {
            // Add touch events for better mobile interaction
            recordBtn.addEventListener('touchstart', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(0.95)';
                this.style.opacity = '0.8';
            });

            recordBtn.addEventListener('touchend', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(1)';
                this.style.opacity = '1';
            });

            // Add haptic feedback for mobile devices
            function addHapticFeedback() {
                if ('vibrate' in navigator) {
                    navigator.vibrate(50); // Short haptic feedback
                }
            }

            // Override click behavior for iOS to ensure proper interaction
            if (browserInfo.isIOS) {
                recordBtn.style.cursor = 'pointer';
                recordBtn.style.webkitTapHighlightColor = 'transparent';
                
                // Add additional iOS-specific handling
                recordBtn.addEventListener('touchstart', function(event) {
                    addHapticFeedback();
                });
            }
        }

        clearBtn.addEventListener('click', clearTranscript);

        languageSelect.addEventListener('change', function() {
            if (recognition) {
                recognition.lang = this.value;
            }
        });

        // TTS Event Listeners
        speechRateSlider.addEventListener('input', function() {
            rateValue.textContent = this.value + 'x';
        });

        speechVolumeSlider.addEventListener('input', function() {
            volumeValue.textContent = Math.round(this.value * 100) + '%';
        });

        speakBtn.addEventListener('click', function() {
            const text = textInput.value.trim();
            if (!text) {
                alert('Please enter text to speak');
                return;
            }

            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }

            console.log('üîä Starting TTS with:', {
                text: text.substring(0, 50) + '...',
                selectedVoice: voiceSelect.value,
                rate: speechRateSlider.value,
                volume: speechVolumeSlider.value
            });

            updateTTSStatus('processing', 'Generating speech...');
            
            // For actual TTS, we'll use Web Speech API as a demo
            // In production, this would call your TTS.py backend
            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.rate = parseFloat(speechRateSlider.value);
            currentUtterance.volume = parseFloat(speechVolumeSlider.value);
            
            // Properly match voice selection with available system voices
            const voices = speechSynthesis.getVoices();
            const selectedVoice = voiceSelect.value;
            
            // Extract language and gender preferences from selected voice
            let targetLang = 'en-US';
            let preferredGender = 'female';
            let voiceName = '';
            
            // Parse the selected Neural voice
            if (selectedVoice.includes('en-US')) targetLang = 'en-US';
            else if (selectedVoice.includes('en-GB')) targetLang = 'en-GB';
            else if (selectedVoice.includes('en-AU')) targetLang = 'en-AU';
            else if (selectedVoice.includes('en-CA')) targetLang = 'en-CA';
            else if (selectedVoice.includes('en-IN')) targetLang = 'en-IN';
            
            // Extract the voice name (e.g., "Jenny" from "en-US-JennyNeural")
            const voiceMatch = selectedVoice.match(/en-[A-Z]{2}-([A-Za-z]+)Neural/);
            if (voiceMatch) {
                voiceName = voiceMatch[1].toLowerCase();
            }
            
            // Comprehensive male voice detection
            const maleVoices = [
                'guy', 'davis', 'brandon', 'christopher', 'eric', 'jacob', 
                'jason', 'roger', 'steffan', 'ryan', 'william', 'liam', 
                'prabhat', 'mark', 'george', 'david', 'james', 'thomas',
                'male', 'man', 'boy'
            ];
            
            const femaleVoices = [
                'jenny', 'aria', 'amber', 'ana', 'cora', 'elizabeth', 
                'jane', 'michelle', 'monica', 'nancy', 'sara', 'sonia',
                'natasha', 'clara', 'neerja', 'susan', 'hazel', 'zira',
                'female', 'woman', 'girl'
            ];
            
            // Determine gender preference
            if (maleVoices.includes(voiceName)) {
                preferredGender = 'male';
            } else if (femaleVoices.includes(voiceName)) {
                preferredGender = 'female';
            } else {
                // Default based on common patterns
                preferredGender = maleVoices.some(name => selectedVoice.toLowerCase().includes(name)) ? 'male' : 'female';
            }
            
            // Enhanced voice matching with better browser compatibility
            function findBestVoice(voices, selectedVoice, targetLang, preferredGender, voiceName) {
                let bestVoice = null;
                let bestScore = -1;
                const fallbackVoices = [];
                
                console.log(`üîç Looking for voice: ${selectedVoice} (${targetLang}, ${preferredGender}, ${voiceName})`);
                console.log(`üé§ Available voices (${voices.length}):`, voices.map(v => `${v.name} (${v.lang})`));
                
                voices.forEach(voice => {
                    let score = 0;
                    const sysVoiceName = voice.name.toLowerCase();
                    const sysVoiceLang = voice.lang;
                    
                    // Store potential fallbacks
                    if (sysVoiceLang.startsWith('en')) {
                        fallbackVoices.push(voice);
                    }
                    
                    // Language matching (highest priority)
                    if (sysVoiceLang === targetLang) {
                        score += 100;
                    } else if (sysVoiceLang.startsWith(targetLang.split('-')[0])) {
                        score += 50; // Same language, different region
                    } else if (sysVoiceLang.startsWith('en')) {
                        score += 25; // Any English
                    }
                    
                    // Exact name matching (very high priority)
                    if (voiceName && sysVoiceName.includes(voiceName)) {
                        score += 200;
                    }
                    
                    // Partial name matching
                    if (voiceName) {
                        const voiceWords = voiceName.split(' ');
                        voiceWords.forEach(word => {
                            if (word.length > 2 && sysVoiceName.includes(word.toLowerCase())) {
                                score += 50;
                            }
                        });
                    }
                    
                    // Gender matching
                    const isMaleVoice = maleVoices.some(male => sysVoiceName.includes(male)) ||
                                       sysVoiceName.includes('male') || sysVoiceName.includes('man');
                    const isFemaleVoice = femaleVoices.some(female => sysVoiceName.includes(female)) ||
                                         sysVoiceName.includes('female') || sysVoiceName.includes('woman');
                    
                    if (preferredGender === 'male' && isMaleVoice) {
                        score += 75;
                    } else if (preferredGender === 'female' && isFemaleVoice) {
                        score += 75;
                    } else if (preferredGender === 'male' && isFemaleVoice) {
                        score -= 25; // Reduced penalty
                    } else if (preferredGender === 'female' && isMaleVoice) {
                        score -= 25; // Reduced penalty
                    }
                    
                    // Quality bonus for Neural/Natural voices
                    if (sysVoiceName.includes('neural') || sysVoiceName.includes('natural') || 
                        sysVoiceName.includes('premium') || sysVoiceName.includes('enhanced')) {
                        score += 15;
                    }
                    
                    // Browser-specific voice preferences
                    if (browserInfo.isChrome && sysVoiceName.includes('google')) {
                        score += 10;
                    } else if (browserInfo.isEdge && sysVoiceName.includes('microsoft')) {
                        score += 10;
                    } else if (browserInfo.isSafari && sysVoiceName.includes('alex')) {
                        score += 10;
                    }
                    
                    console.log(`  ${voice.name} (${voice.lang}): score ${score}`);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestVoice = voice;
                    }
                });
                
                // Enhanced fallback logic
                if (!bestVoice || bestScore < 25) {
                    console.log('üîÑ Using fallback voice selection...');
                    
                    // Try different fallback strategies
                    const strategies = [
                        () => fallbackVoices.find(v => v.lang === targetLang),
                        () => fallbackVoices.find(v => v.lang.startsWith(targetLang.split('-')[0])),
                        () => fallbackVoices.find(v => preferredGender === 'female' ? 
                            femaleVoices.some(f => v.name.toLowerCase().includes(f)) :
                            maleVoices.some(m => v.name.toLowerCase().includes(m))),
                        () => fallbackVoices[0],
                        () => voices[0]
                    ];
                    
                    for (const strategy of strategies) {
                        const voice = strategy();
                        if (voice) {
                            bestVoice = voice;
                            console.log(`üì¢ Fallback voice selected: ${voice.name} (${voice.lang})`);
                            break;
                        }
                    }
                }
                
                return bestVoice;
            }
            
            // Find the best voice using enhanced matching
            const bestVoice = findBestVoice(voices, selectedVoice, targetLang, preferredGender, voiceName);
            
            if (bestVoice) {
                currentUtterance.voice = bestVoice;
                console.log(`üé§ Using voice: ${bestVoice.name} (${bestVoice.lang}) for ${selectedVoice}`);
            }

            currentUtterance.onstart = function() {
                updateTTSStatus('processing', 'Speaking...');
                speakBtn.disabled = true;
                stopSpeechBtn.disabled = false;
            };

            currentUtterance.onend = function() {
                updateTTSStatus('success', 'Speech completed');
                speakBtn.disabled = false;
                stopSpeechBtn.disabled = true;
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
            };

            currentUtterance.onerror = function(event) {
                console.error('üî¥ TTS Error:', event);
                
                let errorMessage = 'Speech error occurred';
                let suggestion = '';
                
                if (event.error) {
                    switch(event.error) {
                        case 'not-allowed':
                            errorMessage = 'Speech synthesis not allowed';
                            suggestion = 'Check browser permissions for audio playback';
                            break;
                        case 'network':
                            errorMessage = 'Network error during speech';
                            suggestion = 'Check your internet connection';
                            break;
                        case 'synthesis-failed':
                            errorMessage = 'Voice synthesis failed';
                            suggestion = 'Try a different voice or shorter text';
                            break;
                        case 'audio-hardware':
                            errorMessage = 'Audio hardware error';
                            suggestion = 'Check your speakers/headphones';
                            break;
                        default:
                            errorMessage = `TTS error: ${event.error}`;
                            suggestion = 'Try refreshing the page';
                    }
                }
                
                updateTTSStatus('idle', errorMessage);
                
                if (suggestion) {
                    console.log('üí° TTS Suggestion:', suggestion);
                    // Could show user notification here if needed
                }
                
                speakBtn.disabled = false;
                stopSpeechBtn.disabled = true;
            };

            speechSynthesis.speak(currentUtterance);
        });

        stopSpeechBtn.addEventListener('click', function() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
                updateTTSStatus('idle', 'Speech stopped');
                speakBtn.disabled = false;
                stopSpeechBtn.disabled = true;
            }
        });

        useTranscriptBtn.addEventListener('click', function() {
            const transcript = transcriptArea.textContent;
            if (transcript && transcript !== 'Your speech will appear here...') {
                textInput.value = transcript;
                updateTTSStatus('success', 'Transcript loaded for TTS');
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
            } else {
                alert('No transcript available. Please record some speech first.');
            }
        });

        saveAudioBtn.addEventListener('click', async function() {
            const text = textInput.value.trim();
            if (!text) {
                alert('Please enter text to save as audio');
                return;
            }

            const selectedVoice = voiceSelect.value;
            const rate = parseFloat(speechRateSlider.value);
            const volume = parseFloat(speechVolumeSlider.value);

            try {
                updateTTSStatus('processing', 'Generating audio file...');
                saveAudioBtn.disabled = true;

                // Call backend TTS API (works both locally and on Vercel)
                const apiEndpoint = window.location.hostname === 'localhost' ? '/tts' : '/api/tts';
                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        voice: selectedVoice,
                        rate: rate,
                        volume: volume
                    })
                });

                // Check if response is ok and has content
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const responseText = await response.text();
                if (!responseText.trim()) {
                    throw new Error('Empty response from server');
                }

                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (jsonError) {
                    console.error('JSON parse error:', jsonError);
                    console.error('Response text:', responseText);
                    throw new Error('Invalid JSON response from server');
                }

                if (result.success) {
                    updateTTSStatus('success', 'Audio downloaded successfully!');
                    
                    // Create download container with link and close button
                    const downloadContainer = document.createElement('div');
                    downloadContainer.className = 'download-container';
                    downloadContainer.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        margin-top: 10px;
                        padding: 10px;
                        background: rgba(99, 102, 241, 0.1);
                        border: 1px solid rgba(99, 102, 241, 0.3);
                        border-radius: 8px;
                        font-size: 14px;
                    `;
                    
                    const downloadLink = document.createElement('a');
                    
                    // Handle both local server (file URL) and Vercel (base64 data)
                    if (result.audio_url) {
                        // Local server response with file URL
                        downloadLink.href = result.audio_url;
                        downloadLink.download = result.filename;
                    } else if (result.audio_data) {
                        // Vercel serverless response with base64 data
                        const audioBlob = new Blob([
                            new Uint8Array(atob(result.audio_data).split('').map(c => c.charCodeAt(0)))
                        ], { type: 'audio/mpeg' });
                        downloadLink.href = URL.createObjectURL(audioBlob);
                        downloadLink.download = `tts_audio_${Date.now()}.mp3`;
                    }
                    
                    downloadLink.textContent = `üíæ ${downloadLink.download}`;
                    downloadLink.style.cssText = `
                        color: #6366f1;
                        text-decoration: none;
                        font-weight: 500;
                        cursor: pointer;
                    `;
                    
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '‚úï';
                    closeButton.style.cssText = `
                        background: none;
                        border: none;
                        color: #6366f1;
                        cursor: pointer;
                        font-size: 16px;
                        padding: 0;
                        width: 20px;
                        height: 20px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    downloadContainer.appendChild(downloadLink);
                    downloadContainer.appendChild(closeButton);
                    
                    // Add download container to the interface
                    const existingContainer = document.querySelector('.download-container');
                    if (existingContainer) {
                        existingContainer.remove();
                    }
                    
                    saveAudioBtn.parentNode.appendChild(downloadContainer);
                    
                    // Add click handlers
                    downloadLink.addEventListener('click', function() {
                        console.log('üéµ Audio download started');
                        setTimeout(() => {
                            if (document.body.contains(downloadContainer)) {
                                downloadContainer.remove();
                                console.log('üóëÔ∏è Download container removed after download');
                            }
                        }, 3000); // Remove after 3 seconds to allow download to complete
                    });
                    
                    closeButton.addEventListener('click', function() {
                        downloadContainer.remove();
                        console.log('üóëÔ∏è Download container manually closed');
                    });
                    
                    // Auto-download
                    downloadLink.click();
                    
                    // Fallback removal after 10 seconds
                    setTimeout(() => {
                        if (document.body.contains(downloadContainer)) {
                            downloadContainer.remove();
                            console.log('üóëÔ∏è Download container removed (fallback)');
                        }
                        updateTTSStatus('idle', 'Ready to Speak');
                    }, 10000);
                } else {
                    updateTTSStatus('idle', 'Error: ' + (result.error || 'Failed to generate audio'));
                    alert('Failed to generate audio: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                updateTTSStatus('idle', 'Network error occurred');
                console.error('TTS API Error:', error);
                
                let errorMessage = 'Error generating audio: ' + error.message;
                
                // Check for specific error types
                if (error.message.includes('405') || error.message.includes('Method Not Allowed')) {
                    errorMessage = '‚ùå Backend Server Required!\n\n' +
                                 'You are using a static file server (like VS Code Live Server).\n' +
                                 'Audio generation requires the Python backend server.\n\n' +
                                 'Please:\n' +
                                 '1. Close this tab\n' +
                                 '2. Run: python tts_backend.py\n' +
                                 '3. Open: http://localhost:8000\n\n' +
                                 'The static server cannot handle TTS requests.';
                } else if (error.message.includes('fetch')) {
                    errorMessage = '‚ùå Backend server not running.\n\n' +
                                 'Please start the server with: python tts_backend.py\n' +
                                 'Then access: http://localhost:8000';
                } else if (error.message.includes('JSON')) {
                    errorMessage = '‚ùå Server response error.\n\n' +
                                 'The server returned invalid data.\n' +
                                 'Check the server console for details.';
                }
                
                alert(errorMessage);
            } finally {
                saveAudioBtn.disabled = false;
            }
        });

        // Utility Functions
        function updateSTTStatus(type, message) {
            const icon = sttStatus.querySelector('i');
            const text = sttStatus.querySelector('span');
            
            sttStatus.className = `status-indicator status-${type}`;
            text.textContent = message;
            
            switch(type) {
                case 'recording':
                    icon.className = 'fas fa-microphone';
                    break;
                case 'processing':
                    icon.className = 'fas fa-spinner fa-spin';
                    break;
                case 'success':
                    icon.className = 'fas fa-check';
                    break;
                default:
                    icon.className = 'fas fa-circle';
            }
        }

        function updateTTSStatus(type, message) {
            const icon = ttsStatus.querySelector('i');
            const text = ttsStatus.querySelector('span');
            
            ttsStatus.className = `status-indicator status-${type}`;
            text.textContent = message;
            
            switch(type) {
                case 'processing':
                    icon.className = 'fas fa-spinner fa-spin';
                    break;
                case 'success':
                    icon.className = 'fas fa-check';
                    break;
                default:
                    icon.className = 'fas fa-circle';
            }
        }

        function resetRecording() {
            isRecording = false;
            recognitionActive = false;
            isRecordingDiv.textContent = 'Recording: False';
            recordBtn.disabled = false;
            stopBtn.disabled = true;
            waveAnimation.style.display = 'none';
        }

        // Enhanced voice loading with browser compatibility
        let voicesLoaded = false;
        let availableVoices = [];
        let voiceLoadAttempts = 0;
        const maxVoiceLoadAttempts = 10;
        
        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            voiceLoadAttempts++;
            
            if (voices.length > 0 && !voicesLoaded) {
                voicesLoaded = true;
                availableVoices = voices;
                
                console.log(`üé§ Loaded ${voices.length} system voices:`, 
                    voices.map(v => `${v.name} (${v.lang})`));
                
                // Group voices by language for better organization
                const voicesByLang = {};
                voices.forEach(voice => {
                    const lang = voice.lang.split('-')[0];
                    if (!voicesByLang[lang]) voicesByLang[lang] = [];
                    voicesByLang[lang].push(voice);
                });
                
                console.log('üåê Voices by language:', voicesByLang);
                
                updateTTSStatus('success', `Voice system ready (${voices.length} voices)`);
                setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
                
                return true;
            } else if (voiceLoadAttempts < maxVoiceLoadAttempts) {
                // Keep trying to load voices
                setTimeout(loadVoices, 500);
            } else {
                console.warn('‚ö†Ô∏è Could not load system voices after maximum attempts');
                updateTTSStatus('idle', 'Limited voice support available');
            }
            
            return false;
        }
        
        // Enhanced voice change event handling for different browsers
        if ('onvoiceschanged' in speechSynthesis) {
            speechSynthesis.onvoiceschanged = loadVoices;
        }
        
        // Immediate load attempt
        loadVoices();
        
        // Browser-specific loading strategies
        if (browserInfo.isChrome || browserInfo.isEdge) {
            // Chrome/Edge typically loads voices asynchronously
            setTimeout(loadVoices, 100);
            setTimeout(loadVoices, 500);
        } else if (browserInfo.isFirefox) {
            // Firefox might need more time
            setTimeout(loadVoices, 1000);
            setTimeout(loadVoices, 2000);
        } else if (browserInfo.isSafari) {
            // Safari has different timing
            setTimeout(loadVoices, 200);
            setTimeout(loadVoices, 1500);
        }
        
        // Universal fallback
        setTimeout(loadVoices, 3000);

        // Clear transcript function
        function clearTranscript() {
            transcriptArea.textContent = 'Your speech will appear here...';
            transcriptArea.dataset.finalText = '';
            textInput.value = '';
        }
        
        // Add voice change listener for feedback (keeping this for user experience)
        voiceSelect.addEventListener('change', function() {
            const selectedVoice = this.value;
            const voiceName = selectedVoice.split('-')[2]?.replace('Neural', '') || selectedVoice;
            updateTTSStatus('success', `Voice changed to ${voiceName}`);
            console.log(`üé§ Voice selection changed to: ${selectedVoice}`);
            setTimeout(() => updateTTSStatus('idle', 'Ready to Speak'), 2000);
        });

        // Comprehensive browser compatibility check and user guidance
        function showBrowserGuidance() {
            const guidance = document.createElement('div');
            guidance.id = 'browser-guidance';
            guidance.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                width: 320px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 14px;
                z-index: 9999;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            let content = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;"><strong>üåê Browser Compatibility</strong><button onclick="this.parentElement.parentElement.remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; border-radius: 50%; width: 24px; height: 24px; cursor: pointer;">‚úï</button></div>';
            
            // Get actual feature support status
            const features = supportedFeatures || checkFeatureSupport();
            const sttIcon = features.speechRecognition ? '‚úÖ' : '‚ùå';
            const ttsIcon = features.speechSynthesis ? '‚úÖ' : '‚ùå';
            
            if (browserInfo.isChrome) {
                content += '<div style="margin-bottom: 8px;">‚úÖ <strong>Chrome:</strong> Full support</div>';
                content += `<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ${sttIcon}<br>‚Ä¢ Voice Synthesis: ${ttsIcon}<br>‚Ä¢ Recommended browser</div>`;
            } else if (browserInfo.isEdge) {
                content += '<div style="margin-bottom: 8px;">‚úÖ <strong>Edge:</strong> Full support</div>';
                content += `<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ${sttIcon}<br>‚Ä¢ Voice Synthesis: ${ttsIcon}<br>‚Ä¢ Recommended browser</div>`;
            } else if (browserInfo.isFirefox) {
                content += '<div style="margin-bottom: 8px;">‚ö†Ô∏è <strong>Firefox:</strong> Limited support</div>';
                content += `<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ${sttIcon} ${!features.speechRecognition ? 'Needs enabling' : ''}<br>‚Ä¢ Voice Synthesis: ${ttsIcon}<br>‚Ä¢ Enable in <code>about:config</code> ‚Üí <code>media.webspeech.recognition.enable</code></div>`;
            } else if (browserInfo.isSafari) {
                content += '<div style="margin-bottom: 8px;">‚ö†Ô∏è <strong>Safari:</strong> Partial support</div>';
                content += `<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ${sttIcon} ${features.speechRecognition ? 'iOS only' : 'Not supported'}<br>‚Ä¢ Voice Synthesis: ${ttsIcon}<br>‚Ä¢ Limited desktop support</div>`;
            } else if (/OPR/.test(navigator.userAgent)) {
                content += '<div style="margin-bottom: 8px;">‚ö†Ô∏è <strong>Opera:</strong> Partial support</div>';
                content += `<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ‚ùå Not supported<br>‚Ä¢ Voice Synthesis: ${ttsIcon}<br>‚Ä¢ Use Chrome or Edge for STT features</div>`;
            } else {
                content += '<div style="margin-bottom: 8px;">‚ùì <strong>Unknown Browser</strong></div>';
                content += `<div style="font-size: 12px; opacity: 0.9;">‚Ä¢ Speech Recognition: ${sttIcon}<br>‚Ä¢ Voice Synthesis: ${ttsIcon}<br>‚Ä¢ For best experience, use Chrome or Edge</div>`;
            }
            
            guidance.innerHTML = content;
            document.body.appendChild(guidance);
            
            // Animate in
            setTimeout(() => {
                guidance.style.opacity = '1';
                guidance.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto-hide after 8 seconds
            setTimeout(() => {
                if (document.body.contains(guidance)) {
                    guidance.style.opacity = '0';
                    guidance.style.transform = 'translateX(100%)';
                    setTimeout(() => guidance.remove(), 300);
                }
            }, 8000);
        }

        // Enhanced feature detection with browser-specific checks
        function checkFeatureSupport() {
            const hasSTTAPI = !!(window.SpeechRecognition || window.webkitSpeechRecognition);
            const hasTTSAPI = !!window.speechSynthesis;
            const hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            
            // Browser-specific STT support detection
            let sttSupported = false;
            if (browserInfo.isMobile) {
                // Mobile device STT support
                if (browserInfo.isAndroidChrome) {
                    // Android Chrome has good STT support
                    sttSupported = hasSTTAPI && hasMediaDevices;
                    debugLog('üì± Android Chrome STT support detected');
                } else if (browserInfo.isIOSSafari) {
                    // iOS Safari has limited STT support (iOS 14.5+)
                    sttSupported = hasSTTAPI;
                    debugLog('üì± iOS Safari STT support:', sttSupported ? 'Available' : 'Not available');
                } else if (browserInfo.isIOSChrome) {
                    // iOS Chrome uses Safari engine but with more limitations
                    sttSupported = hasSTTAPI;
                    debugLog('üì± iOS Chrome STT support:', sttSupported ? 'Available' : 'Not available');
                } else {
                    // Other mobile browsers - limited support
                    sttSupported = hasSTTAPI && hasMediaDevices;
                    debugLog('üì± Mobile browser STT support:', sttSupported ? 'Available' : 'Not available');
                }
            } else if (browserInfo.isChrome || browserInfo.isEdge) {
                sttSupported = hasSTTAPI && hasMediaDevices;
            } else if (browserInfo.isFirefox) {
                // Firefox needs manual enablement
                sttSupported = hasSTTAPI && hasMediaDevices;
                if (sttSupported) {
                    // Test if it's actually enabled
                    try {
                        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                        const testRecognition = new SpeechRecognition();
                        testRecognition.continuous = false;
                        // Firefox throws error if not properly enabled
                    } catch (e) {
                        sttSupported = false;
                        debugLog('Firefox STT not enabled:', e.message);
                    }
                }
            } else if (browserInfo.isSafari) {
                // Safari has very limited STT support
                sttSupported = hasSTTAPI && /iPhone|iPad/.test(navigator.userAgent);
            } else {
                // Other browsers (Opera, etc.) - test basic API availability
                sttSupported = hasSTTAPI && hasMediaDevices;
                
                // Opera specifically has issues with STT
                if (/OPR/.test(navigator.userAgent)) {
                    sttSupported = false; // Opera doesn't support STT properly
                    debugLog('Opera detected - STT not supported');
                }
            }
            
            // Browser-specific TTS support detection
            let ttsSupported = false;
            if (hasTTSAPI) {
                try {
                    // Test if speech synthesis actually works
                    const testUtterance = new SpeechSynthesisUtterance('');
                    ttsSupported = true;
                } catch (e) {
                    ttsSupported = false;
                    debugLog('TTS test failed:', e.message);
                }
            }
            
            const features = {
                speechRecognition: sttSupported,
                speechSynthesis: ttsSupported,
                mediaDevices: hasMediaDevices,
                audioContext: !!(window.AudioContext || window.webkitAudioContext),
                webAudio: 'AudioContext' in window || 'webkitAudioContext' in window,
                // Additional browser info
                browserName: browserInfo.isChrome ? 'Chrome' : 
                           browserInfo.isEdge ? 'Edge' :
                           browserInfo.isFirefox ? 'Firefox' :
                           browserInfo.isSafari ? 'Safari' :
                           /OPR/.test(navigator.userAgent) ? 'Opera' : 'Unknown'
            };
            
            debugLog('üîç Detailed Feature Support:', features);
            
            // Show warnings for missing features
            if (!features.speechRecognition) {
                updateSTTStatus('idle', 'Speech Recognition not supported in this browser');
            }
            
            if (!features.speechSynthesis) {
                updateTTSStatus('idle', 'Speech Synthesis not supported');
            }
            
            if (!features.mediaDevices) {
                debugLog('‚ö†Ô∏è Media Devices API not available');
            }
            
            return features;
        }

        // Initialize feature support checking
        const supportedFeatures = checkFeatureSupport();
        
        // Show browser guidance on page load
        setTimeout(showBrowserGuidance, 2000);

        // Check if we're running on the correct Python backend server
        async function checkServerType() {
            try {
                const response = await fetch('/test', { method: 'GET' });
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === "Server is running") {
                        console.log('‚úÖ Connected to Python TTS backend server');
                        return true;
                    }
                }
            } catch (error) {
                // Likely using a static file server
                const currentUrl = window.location.href;
                if (currentUrl.includes('127.0.0.1:5500') || 
                    currentUrl.includes('localhost:5500') ||
                    currentUrl.includes('liveserver') ||
                    !currentUrl.includes('localhost:8000')) {
                    
                    // Show warning for static file server users
                    const warningDiv = document.createElement('div');
                    warningDiv.innerHTML = `
                        <div style="position: fixed; top: 0; left: 0; right: 0; z-index: 10000; 
                                    background: linear-gradient(45deg, #ff6b6b, #ee5a24); 
                                    color: white; padding: 15px; text-align: center; 
                                    font-family: Arial, sans-serif; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
                            <strong>‚ö†Ô∏è Static File Server Detected!</strong><br>
                            <span style="font-size: 14px;">
                                For full TTS functionality, please run: <code>python tts_backend.py</code> 
                                and access <code>http://localhost:8000</code>
                            </span>
                            <button onclick="this.parentElement.parentElement.remove()" 
                                    style="margin-left: 10px; background: rgba(255,255,255,0.2); 
                                           border: 1px solid white; color: white; padding: 5px 10px; 
                                           border-radius: 3px; cursor: pointer;">‚úï</button>
                        </div>
                    `;
                    document.body.appendChild(warningDiv);
                }
                return false;
            }
        }

        // Cleanup temporary files on page load
        async function cleanupTempFiles() {
            try {
                const response = await fetch('/cleanup', { method: 'GET' });
                if (response.ok) {
                    const result = await response.json();
                    if (result.cleaned_files > 0) {
                        console.log(`üßπ Cleaned up ${result.cleaned_files} temporary files`);
                    }
                }
            } catch (error) {
                console.log('Note: Could not clean up temporary files (server may not be running)');
            }
        }

        // Check server type and cleanup on page load
        checkServerType();
        cleanupTempFiles();
        window.addEventListener('beforeunload', cleanupTempFiles);

        // Final initialization and compatibility summary
        function initializeApp() {
            console.log('üöÄ Initializing Speech Processing Suite...');
            console.log('üìä Browser Compatibility Summary:', {
                browser: browserInfo,
                features: supportedFeatures,
                speechRecognitionReady: !!recognition,
                voicesLoaded: voicesLoaded,
                availableVoicesCount: availableVoices.length
            });
            
            // Set initial status messages
            if (supportedFeatures.speechRecognition && recognition) {
                updateSTTStatus('idle', 'Ready to Listen');
            } else {
                updateSTTStatus('idle', 'Speech Recognition unavailable');
            }
            
            if (supportedFeatures.speechSynthesis) {
                updateTTSStatus('idle', 'Ready to Speak');
            } else {
                updateTTSStatus('idle', 'Speech Synthesis unavailable');
            }
            
            // Log final compatibility status
            const compatibilityScore = [
                supportedFeatures.speechRecognition ? 25 : 0,
                supportedFeatures.speechSynthesis ? 25 : 0,
                supportedFeatures.mediaDevices ? 25 : 0,
                (browserInfo.isChrome || browserInfo.isEdge) ? 25 : 
                (browserInfo.isFirefox || browserInfo.isSafari) ? 15 : 5
            ].reduce((a, b) => a + b, 0);
            
            console.log(`‚ú® App initialized with ${compatibilityScore}% compatibility`);
            
            if (compatibilityScore < 50) {
                console.warn('‚ö†Ô∏è Low compatibility detected. Some features may not work properly.');
            }
        }
        
        // Initialize the app
        setTimeout(initializeApp, 1000);
    </script>
</body>
</html>